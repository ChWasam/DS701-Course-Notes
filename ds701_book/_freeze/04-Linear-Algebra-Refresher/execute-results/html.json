{
  "hash": "b74afd81059fca954194f5dfc0f0850e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Linear Algebra Refresher\njupyter: python3\n---\n\n# Introduction\n\n## Introduction to linear algebra\n\n[![](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/tools4ds/DS701-Course-Notes/blob/main/ds701_book/jupyter_notebooks/04-Linear-Algebra-Refresher.ipynb)\n\nLinear algebra is the branch of mathematics involving vectors and matrices. In particular, how vectors are transformed.  Knowledge of linear algebra is essential in data science. \n\n## Linear algebra\n\nLinear algebra allows us to understand the operations and transformations used to manipulate and extract information from data.\n\n:::: {.frag}\nExamples\n\n:::: {.incremental}\n- Deep neural networks use matrix-vector and matrix-matrix multiplication.\n- Natural language processing use the dot product to determine word similarity.\n- Least squares uses matrix inverses and matrix factorizations to compute models for predicting continuous values.\n- PCA (dimensionality reduction) uses the matrix factorization called the Singular Value Decomposition (SVD).\n- Graphs are described by adjacency matrices. Eigenvectors and eigenvalues of this matrix provide information about the graph structure.\n::::\n::::\n\n::: {.content-visible when-profile=\"slides\"}\n## Lecture overview\n:::\n\n:::: {.fragment}\nLinear algebra is used to implement data science algorithms efficiently and accurately.\n::::\n\n:::: {.fragment}\nYou will not have to program linear algebra algorithms. You will use appropriate Python packages.\n::::\n\n::: {.content-hidden when-profile=\"slides\"}\nThis lecture is a review of some aspects of linear algebra that are important for data science. Given the prerequisites for this course, I assume that you previously learned this material. \n:::\n\n:::: {.fragment}\nThe goal of this lecture is to refresh the following topics:\n\n:::: {.incremental}\n- vectors,\n- matrices,\n- operations with vectors and matrices,\n- eigenvectors and eigenvalues,\n- linear systems and least squares,\n- matrix factorizations.\n::::\n::::\n\n::: {.content-hidden when-profile=\"web\"}\n## References\n:::\n\nBelow is a list of very useful resources for learning about linear algebra:\n\n- __Linear Algebra and Its Applications (6th edition)__, David C. Lay, Judi J. McDonald, and Steven R. Lay, Pearson, 2021,\n- __Introduction to Linear Algebra (6th edition)__, Gilbert Strang, Wellesley-Cambridge Press, 2023,\n    - Gilbert Strang's [lecture videos](https://youtube.com/playlist?list=PL221E2BBF13BECF6C&si=ImY77CfkyNVJvPtt)\n- __Linear Algebra and Learning from Data__, Gilbert Strang, Wellesley-Cambridge Press, 2019,\n- __Numerical Linear Algebra__, Lloyn N. Trefethen and David Bau, SIAM, 1997.\n\n\n# Vectors and Vector Operations\n\n## Vectors\n\nA vector of length $n$, $\\mathbf{x}\\in\\mathbb{R}^{n}$, is a 1-dimensional (1-D) array of real numbers\n\n$$\n\\mathbf{x} =\n\\begin{bmatrix}\nx_1 \\\\\nx_2 \\\\\n\\vdots \\\\\nx_n\n\\end{bmatrix}.\n$$\n\n\nWhen discussing vectors we will only consider column vectors. A row vector can always be obtained from a column vector via transposition\n\n$$\n\\mathbf{x}^{T} = [x_1, x_2, \\ldots, x_n].\n$$\n\n## Geometric interpretation of vectors\n\n* Vectors in $\\mathbb{R}^{2}$ can be visualized as points in a 2-D plane (or arrows originating at the origin), \n* Vectors in $\\mathbb{R}^{3}$ can be visualized as points in a 3-D space (or arrows originating at the origin).\n\nLet \n\n$$\n\\mathbf{x}=\\begin{bmatrix} 2 \\\\ 2 \\end{bmatrix},~\n\\mathbf{y} = \\begin{bmatrix} 3 \\\\ -1 \\end{bmatrix},~\n\\mathbf{z} = \\begin{bmatrix} -2 \\\\ -1 \\end{bmatrix}.\n$$\n\n::: {.content-hidden when-profile=\"slides\"}\nThese vectors are illustrated in @fig-vector-viz.\n:::\n\n::: {#cell-fig-vector-viz .cell execution_count=1}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nimport numpy as np\nfig = plt.figure()\nax = plt.gca()\nx = np.array([2, 2])\ny = np.array([3, -1])\nz = np.array([-2, -1])\nV = np.array([x, y, z])\norigin = np.array([[0, 0, 0], [0, 0, 0]])\nplt.quiver(*origin, V[:, 0], V[:, 1], \n           color=['r', 'b', 'g'], \n           angles='xy', \n           scale_units='xy', \n           scale=1)\nax.set_xlim([-6, 6])\nax.set_ylim([-2, 4])\nax.text(3.3, -1.1, '$(3,-1)$', size=16)\nax.text(2.3, 1.9, '$(2,2)$', size=16)\nax.text(-3.7, -1.3, '$(-2,-1)$', size=16)\nax.grid()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Illustration of vectors](04-Linear-Algebra-Refresher_files/figure-html/fig-vector-viz-output-1.png){#fig-vector-viz width=573 height=416}\n:::\n:::\n\n\n## Vector Operations\n\n**Scalar multiplication:** Let $c\\in\\mathbb{R}$, $\\mathbf{x}\\in\\mathbb{R}^{n}$, then\n$$\nc\\mathbf{x} = \\begin{bmatrix} cx_1 \\\\ cx_2 \\\\ \\vdots \\\\ cx_n \\end{bmatrix}.\n$$\n\n---\n\nMultiplication by a scalar $c\\in\\mathbb{R}$. \n\n* For $c>1$ the vector is _lengthened_. \n* For $0<c<1$ the vector _shrinks_. \n* If we negate $c$ the direction of the vector is _flipped 180 degrees_. \n\nFigure @fig-vector-scaling shows the vector $\\mathbf{x} = [2, 2]$ multiplied by the scalar value $c=2$.\n\n::: {#cell-fig-vector-scaling .cell execution_count=2}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nimport numpy as np\nfig = plt.figure()\nax = plt.gca()\nx = np.array([2, 2])\ny = np.array([4, 4])\nV = np.array([x, y])\norigin = np.array([[0, 0], [0, 0]])\nplt.quiver(*origin, V[:, 0], V[:, 1], \n           color=['r', 'b'], \n           angles='xy', \n           scale_units='xy', \n           scale=1,\n           alpha= 0.5)\nax.set_xlim([-5, 5])\nax.set_ylim([-1, 5])\nax.text(2.3, 1.9, '$x$', size=16)\nax.text(4.3, 3.9, '$cx$', size=16)\nax.grid()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Scalar multiplication of a vector](04-Linear-Algebra-Refresher_files/figure-html/fig-vector-scaling-output-1.png){#fig-vector-scaling width=569 height=416}\n:::\n:::\n\n\n---\n\n**Vector addition:** Let $\\mathbf{u},\\mathbf{v}\\in\\mathbb{R}^{n}$ then\n$$\n\\mathbf{u} + \\mathbf{v} = \\begin{bmatrix} u_1 + v_1 \\\\ u_2 + v_2 \\\\ \\vdots \\\\ u_n + v_n \\end{bmatrix}.\n$$\n\n---\n\nWe plot the sum of $\\mathbf{u} = [1, 2]$ and $\\mathbf{v} = [4, 1]$ in @fig-vector-addition. \nThe sum $\\mathbf{u} + \\mathbf{v} = [5, 3]$ is obtained by placing the tip of one vector to the tail of the other vector. \n\n::: {#cell-fig-vector-addition .cell execution_count=3}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nimport numpy as np\nfig = plt.figure()\nax = plt.gca()\nu = np.array([1, 2])\nv = np.array([4, 1])\nw = np.array([5, 3])\nV = np.array([u, v, w])\norigin = np.array([[0, 0, 0], [0, 0, 0]])\nplt.quiver(*origin, V[:, 0], V[:, 1], \n           color=['b', 'b', 'r'], \n           angles='xy', \n           scale_units='xy', \n           scale=1)\nax.set_xlim([-1, 6])\nax.set_ylim([-1, 4])\nax.text(1.3, 1.9, '$u$', size=16)\nax.text(4.3, 1.2, '$v$', size=16)\nax.text(5.3, 2.9, '$u+v$', size=16)\nplt.plot([1, 5], [2, 3], 'g--')\nplt.plot([4, 5], [1, 3], 'g--')\nax.grid()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Vector addition](04-Linear-Algebra-Refresher_files/figure-html/fig-vector-addition-output-1.png){#fig-vector-addition width=573 height=416}\n:::\n:::\n\n\n---\n\n**Dot product:** Let $\\mathbf{u},\\mathbf{v}\\in\\mathbb{R}^{n}$ then the dot product is defined as\n$$\n\\mathbf{u}\\cdot\\mathbf{v} = \\sum_{i=0}^n u_i v_i.\n$$\n\n**Vector 2-norm:** The 2-norm of a vector $\\mathbf{v}\\in\\mathbb{R}^{n}$ is defined as\n$$\n\\Vert \\mathbf{v}\\Vert_2 = \\sqrt{\\mathbf{v}\\cdot\\mathbf{v}} = \\sqrt{\\sum_{i=1}^n v_i^2}.\n$$\n\nThis norm is referred to as the $\\ell_2$ norm. In these notes, the notation $\\Vert \\mathbf{v} \\Vert$, indicates the 2-norm.\n\n---\n\n**Unit vector:** A unit vector $\\mathbf{v}$ is a vector such that $\\Vert \\mathbf{v} \\Vert_2 = 1$. \n    - All vectors of the form $\\frac{\\mathbf{v}}{\\Vert \\mathbf{v} \\Vert_2 }$ are unit vectors.\n\n**Distance:** Let $\\mathbf{u},\\mathbf{v}\\in\\mathbb{R}^{n}$, the distance between $\\mathbf{u}$ and $\\mathbf{v}$ is\n$$\n\\Vert \\mathbf{u} - \\mathbf{v} \\Vert_2.\n$$\n\n**Orthogonality:** Two vectors $\\mathbf{u},\\mathbf{v}\\in\\mathbb{R}^{n}$ are orthogonal if and only if $\\mathbf{u}\\cdot\\mathbf{v}=0$. \n\n**Angle between vectors:**  Let $\\mathbf{u},\\mathbf{v}\\in\\mathbb{R}^{n}$, the angle between these vectors is \n$$\n\\cos{\\theta} = \\frac{\\mathbf{u}\\cdot\\mathbf{v}}{\\Vert \\mathbf{u}\\Vert_2 \\Vert\\mathbf{v}\\Vert_2}.\n$$\n\n---\n\nThe dot product of two vectors $\\mathbf{u}, \\mathbf{v}$ can be used to project $\\mathbf{u}$ onto $\\mathbf{v}$\n\n$$\n\\mathrm{proj}_{\\mathbf{v}}\\mathbf{u} = \\frac{\\mathbf{u}\\cdot\\mathbf{v}}{\\Vert \\mathbf{v} \\Vert^2}\\mathbf{v}.\n$$\n\nThis is illustrated in @fig-dot-product.\n\n::: {#cell-fig-dot-product .cell execution_count=4}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nax = plt.gca()\n\n# Define vectors u and v\nu = np.array([1, 2])\nv = np.array([4, 1])\n\n# Project u onto v\nprojection = np.dot(u, v) * v / np.dot(v, v)\n\nV = np.array([u, v, projection])\n\norigin = np.array([[0, 0, 0], [0, 0, 0]])\nplt.quiver(*origin, V[:, 0], V[:, 1], color=['b', 'b', 'r'], angles='xy', scale_units='xy', scale=1)\n\nax.set_xlim([-1, 6])\nax.set_ylim([-1, 4])\nax.text(1.3, 1.9, r'$\\mathbf{u}$', size=16)\nax.text(4.3, 1.2, r'$\\mathbf{v}$', size=16)\nax.text(0.4, -0.3, r'$\\mathrm{proj}_{\\mathbf{v}}\\mathbf{u}$', size=16)\n\nplt.plot([u[0], projection[0]], [u[1], projection[1]], 'g--')\n\nax.grid()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Dot product](04-Linear-Algebra-Refresher_files/figure-html/fig-dot-product-output-1.png){#fig-dot-product width=573 height=416}\n:::\n:::\n\n\nObserve that a right angle forms between the vectors $\\mathbf{u}$ and $\\mathbf{v}$ when $\\mathbf{u}\\cdot \\mathbf{v} = 0$. \n\nAnd we can calculate the angle between $\\mathbf{u}$ and $\\mathbf{v}$.\n\n::: {#e45e483d .cell execution_count=5}\n``` {.python .cell-code}\n# Define vectors u and v\nu = np.array([1, 2])\nv = np.array([4, 1])\n\ntheta = np.arccos(np.dot(u, v) / (np.linalg.norm(u) * np.linalg.norm(v)))\nprint(f\"The angle between u and v is {theta} radians or {np.degrees(theta)} degrees.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe angle between u and v is 0.8621700546672264 radians or 49.398705354995535 degrees.\n```\n:::\n:::\n\n\n---\n\n**Linear dependence:** A set of $n$ vectors $\\mathbf{v}_{1}, \\ldots, \\mathbf{v}_{n}\\in\\mathbb{R}^n$ is linearly dependent if there exists scalars $a_1,\\ldots, a_n$ not all zero such that \n$$\n\\sum_{i=1}^{n} a_i \\mathbf{v}_i = 0.\n$$\n\n**Linear independence:** The vectors $\\mathbf{v}_{1}, \\ldots, \\mathbf{v}_{n}$ are linearly independent if they are not linearly dependent, i.e., the equation\n$$\na_1 \\mathbf{v}_1 + \\cdots + a_n \\mathbf{v}_n = 0,\n$$\n\nis only satisfied if $a_i=0$ for $i=1, \\ldots,n$.\n\n**Span:** Given a set of vectors $V = \\{\\mathbf{v}_{1}, \\ldots, \\mathbf{v}_{n}\\}$, where $\\mathbf{v}_i\\in\\mathbb{R}^n$, the span(V) is the set of all linear combinations of vectors in $V$.\n\n\n# Matrices\n\n## Matrices\n\nA matrix $A\\in\\mathbb{R}^{m\\times n}$ is a 2-D array of numbers\n\n$$\nA = \n\\begin{bmatrix}\na_{11} & a_{12} & \\cdots & a_{1n} \\\\\na_{21} & a_{22} & \\cdots & a_{2n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{m1} &a_{m2} & \\cdots & a_{mn} \\\\\n\\end{bmatrix},\n$$\n\nwith $m$ rows and $n$ columns. The element at row $i$ and column $j$ is denoted $a_{ij}$. If $m=n$ we call it a square matrix.\n\n---\n\nSimilar to vectors, we can multiply matrices by scalar values and add matrices of the same dimension, i.e.,\n\n**Scalar multiplication:** Let $c\\in\\mathbb{R}$ and $A\\in\\mathbb{R}^{m\\times n}$, then\n$$\ncA =\n\\begin{bmatrix}\nca_{11} & ca_{12} & \\cdots & ca_{1n} \\\\\nca_{21} & ca_{22} & \\cdots & ca_{2n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nca_{m1} & ca_{m2} & \\cdots & ca_{mn} \\\\\n\\end{bmatrix}.\n$$\n\n---\n\n**Matrix addition:** Let $A, B\\in\\mathbb{R}^{m\\times n}$, then \n$$\nA + B =\n\\begin{bmatrix}\na_{11} + b_{11} & a_{12} + b_{12} & \\cdots & a_{1n} + b_{1n} \\\\\na_{21} + b_{21} & a_{22} + b_{22} & \\cdots & a_{2n} + b_{2n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{m1} + b_{m1} & a_{m2} + b_{m2} & \\cdots & a_{mn} + b_{mn} \\\\\n\\end{bmatrix}\n$$\n\n---\n\n**Transpose:** The transpose $A^{T}$ is defined as\n\n$$\nA^{T} = \n\\begin{bmatrix}\na_{11} & a_{21} & \\cdots & a_{m1} \\\\\na_{12} & a_{22} & \\cdots & a_{m2} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{1n} &a_{2n} & \\cdots & a_{nm} \\\\\n\\end{bmatrix}.\n$$\n\nThe transpose turns columns of the matrix into rows (equivalently rows into columns). A square matrix is called symmetric if $A=A^{T}$.\n\n## Matrix multiplication\n\nWe discuss the following two important matrix multiplication operations\n\n- matrix-vector multiplication,\n- matrix-matrix multiplication.\n\n::: {.content-hidden when-profile=\"slides\"}\n### Matrix-vector multiplication\n:::\n\n::: {.content-visible when-profile=\"slides\"}\n## Matrix-vector multiplication\n:::\n\nLet $A\\in\\mathbb{R}^{m\\times n}$ and $\\mathbf{x}\\in\\mathbb{R}^{n}$, then $A\\mathbf{x}\\in\\mathbb{R}^{m}$\ncan be defined _row-wise_ as \n\n$$\nA\\mathbf{x} = \n\\begin{bmatrix}\na_{11} & a_{12} & \\cdots & a_{1n} \\\\\na_{21} & a_{22} & \\cdots & a_{2n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{m1} & a_{m2} & \\cdots & a_{mn} \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nx_1 \\\\\nx_2 \\\\\n\\vdots \\\\\nx_n\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nx_1a_{11} + x_2 a_{12} + \\cdots + x_na_{1n} \\\\\nx_1a_{21} + x_2 a_{22} + \\cdots + x_na_{2n} \\\\\n\\vdots \\\\\nx_1a_{m1} + x_2 a_{m2} + \\cdots + x_na_{mn} \\\\\n\\end{bmatrix}.\n$$\n\n::: {.content-visible when-profile=\"slides\"}\n## Matrix-vector multiplication cont.\n:::\n\nEquivalently, this means that $A\\mathbf{x}$ is a linear combination of the _columns_ of $A$, i.e.,\n\n$$\nA\\mathbf{x} = \nx_1 \\begin{bmatrix} a_{11} \\\\ a_{21} \\\\ \\vdots \\\\ a_{m1}  \\end{bmatrix} \n+ \nx_2  \\begin{bmatrix} a_{12} \\\\ a_{22} \\\\ \\vdots \\\\ a_{m2}  \\end{bmatrix}\n+\n\\cdots\n+\nx_n \\begin{bmatrix} a_{1n} \\\\ a_{2n} \\\\ \\vdots \\\\ a_{mn}  \\end{bmatrix}.\n$$\n\nObserve that the matrix $A$ is a linear transformation that maps vectors in $\\mathbb{R}^{n}$ to $\\mathbb{R}^{m}$.\n\n::: {.content-hidden when-profile=\"slides\"}\n### Matrix-matrix multiplication\n:::\n\n::: {.content-visible when-profile=\"slides\"}\n## Matrix-matrix multiplication\n:::\n\nLet $A\\in\\mathbb{R}^{m\\times n}$ and $B\\in\\mathbb{R}^{n\\times p}$, then the elements of $C=AB\\in\\mathbb{R}^{m\\times p}$ are\n\n$$\nc_{ij} = \\sum_{k=1}^{n} a_{ik}b_{kj},\n$$\n\nfor $i=1,\\ldots, m$ and $j=1, \\ldots, p$.\n\n\n# Vector spaces\n\n## Vector spaces\n\nAn essential concept in linear algebra is the notion of a **vector space**.\n\nA vector space is a set $V$ such that for any 2 elements in the set, say $\\mathbf{u},\\mathbf{v}\\in V$, and any scalars, $c$ and $d$, then $c\\mathbf{u} + d\\mathbf{v}\\in V$. \n\nIn addition, a vector space must satisfy the following properties\n\n:::: {.incremental}\n1. $\\mathbf{u} + (\\mathbf{v} + \\mathbf{w}) = (\\mathbf{u} + \\mathbf{v}) + \\mathbf{w}$ (associativity).\n1. $\\mathbf{u} + \\mathbf{v} = \\mathbf{v} + \\mathbf{u}$ (commutativity).\n1. There exists $\\mathbf{0}\\in V$ such that $\\mathbf{v} + \\mathbf{0} = \\mathbf{v}$ for all $\\mathbf{v}\\in V$ (identity element).\n1. For every $\\mathbf{v}\\in V$, there exists $-\\mathbf{v}\\in V$ such that $\\mathbf{v} + (-\\mathbf{v}) = \\mathbf{0}$ (inverse).\n1. $c(d\\mathbf{v}) = (cd)\\mathbf{v}$\n1. $1\\mathbf{v} = \\mathbf{v}$\n1. $c(\\mathbf{u} + \\mathbf{v}) = c\\mathbf{u} + c\\mathbf{v}$\n1. $(c + d)\\mathbf{v} = c\\mathbf{v} + d\\mathbf{v}$\n::::\n\n::: {.content-hidden when-profile=\"web\"}\n## Vector spaces continued\n:::\n\nSome examples of vector spaces are:\n\n:::: {.incremental}\n- The set of n-dimensional vectors with real numbers, i.e., $\\mathbb{R}^n$.\n- Given a matrix $A\\in\\mathbb{R}^{m\\times n}$, \n    - the _column space_ $col(A)$, which is the span of all columns in the matrix $A$ is a vector space. \n    - The similarly defined _row space_ is also a vector space.\n- Given a matrix $A\\in\\mathbb{R}^{n\\times n}$, the set of all solutions to the\n  equation $A\\mathbf{x} = \\mathbf{0}$ is a vector space. This space is called the\n  null space of matrix $A$.\n- The set of all $m\\times n$ matrices with real numbers is also a vector space.\n- The set of all polynomials of degree $n$ is a vector space.\n::::\n\n# Important matrices\n\n## Important matrices\n\nWe introduce notation for some commonly used and important matrices.\n\n::: {.content-visible when-profile=\"slides\"}\n## Identity matrix\n:::\n\nThe $n \\times n$ identity matrix is\n\n$$\n\\mathbf{I} = \n\\begin{bmatrix}\n1 & 0 & \\cdots & 0 \\\\\n0 & 1 & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n0 & 0 & \\cdots & 1 \\\\\n\\end{bmatrix}.\n$$\n\nFor every $\\mathbf{A}\\in\\mathbb{R}^{n\\times n}$, then $\\mathbf{AI} = \\mathbf{IA}$. \n\n::: {.content-visible when-profile=\"slides\"}\n## Matrix inverse\n:::\n\nThe inverse $A^{-1}\\in\\mathbb{R}^{n\\times n}$ is defined as the matrix for which \n$$AA^{-1} = A^{-1}A = I,$$ \n\nWhen $A^{-1}$ exists the matrix is said to be _invertible_. \n\nNote that $(AB)^{-1} = B^{-1}A^{-1}$ for invertible $B\\in\\mathbb{R}^{n\\times n}$.\n\n::: {.content-visible when-profile=\"slides\"}\n## Diagonal matrices\n:::\nA diagonal matrix $D\\in\\mathbb{R}^{n\\times n}$ has entries $d_{ij}=0$ if $i\\neq j$, i.e.,\n\n$$\nD =\n\\begin{bmatrix}\nd_{11} & 0 & \\cdots & 0 \\\\\n0 & d_{22} & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n0 & 0 & \\cdots & d_{nn} \\\\\n\\end{bmatrix}.\n$$\n\n::: {.content-visible when-profile=\"slides\"}\n## Orthogonal matrices\n:::\nA square matrix $Q\\in\\mathbb{R}^{n}$ is orthogonal if \n\n$$QQ^{T}=Q^{T}Q=I.$$ \n\nIn particular, the inverse of an orthogonal matrix is it's transpose.\n\n::: {.content-visible when-profile=\"slides\"}\n## Lower triangular matrices\n:::\nA lower triangular matrix $L\\in\\mathbb{R}^{n\\times n}$ is a matrix where all the entries above the main diagonal are zero\n\n$$\nL =\n\\begin{bmatrix}\nl_{11} & 0 & \\cdots & 0 \\\\\nl_{12} & l_{22} & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nl_{1n} & l_{n2} & \\cdots & l_{nn} \\\\\n\\end{bmatrix}.\n$$\n\n::: {.content-visible when-profile=\"slides\"}\n## Upper triangular matrices\n:::\nAn upper triangular matrix $U\\in\\mathbb{R}^{n\\times n}$ is a matrix where all the entries below the main diagonal are zero\n\n$$\nU = \n\\begin{bmatrix}\nu_{11} & u_{12} & \\cdots & u_{1n} \\\\\n0 & u_{22} & \\cdots & u_{2n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n0 & 0 & \\cdots & u_{nn} \\\\\n\\end{bmatrix}.\n$$\n\n::: {.content-visible when-profile=\"web\"}\nThe inverse of a lower triangular matrix is itself a lower triangular matrix. This is also true for upper triangular matrices, i.e., the inverse is also upper triangular.\n:::\n\n## Eigenvalues and eigenvectors\n\nAn eigenvector of an $n\\times n$ matrix $\\mathbf{A}$ is a nonzero vector $\\mathbf{x}$ such that \n\n$$\nA\\mathbf{x} = \\lambda\\mathbf{x}\n$$ \n\nfor some scalar $\\lambda.$ \n\nThe scalar $\\lambda$ is called an eigenvalue.\n\nAn $n \\times n$ matrix has at most $n$ distinct eigenvectors and at most $n$ distinct eigenvalues.\n\n::: {.content-visible when-profile=\"slides\"}\n# Matrix decompositions\n:::\n\n::: {.content-visible when-profile=\"web\"}\n## Matrix decompositions\n\nWe introduce here important matrix decompositions. These are useful in solving linear equations. Furthermore they play an important role in various data science applications.\n:::\n\n::: {.content-visible when-profile=\"web\"}\n### LU factorization\n:::\n\n::: {.content-visible when-profile=\"slides\"}\n## LU factorization\n:::\n\nAn LU decomposition of a square matrix $A\\in\\mathbb{R}^{n\\times n}$ is a factorization of $A$ into a product of matrices\n\n$$ \nA = LU,\n$$\n\nwhere $L$ is a lower triangular square matrix and $U$ is an triangular square matrix. For example, when $n=3$, we have\n\n$$ \n\\begin{bmatrix}\na_{11} & a_{12} & a_{13} \\\\\na_{21} & a_{22} & a_{23} \\\\\na_{31} & a_{32} & a_{33} \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nl_{11} & 0 & 0 \\\\\nl_{21} & l_{22} & 0\\\\\nl_{31} & l_{32} & a_{33} \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nu_{11} & u_{12} & u_{13} \\\\\n0 & u_{22} & u_{23} \\\\\n0 & 0 & u_{33} \\\\\n\\end{bmatrix}\n$$\n\nIt simplifies the process of solving linear equations and is more numerically\nstable than computing the inverse of $A$.\n\n<br>\nYou can then solve this in two steps:\n\n1. **Forward substitution:** First, solve the equation $L\\mathbf{y} = \\mathbf{b}$ for $\\mathbf{y}$.\n2. **Backward substitution:** Then, solve $U\\mathbf{x} = \\mathbf{y}$ for $\\mathbf{x}$.\n\nThis method is particularly useful because triangular matrices are much easier to\nwork with. It can make solving linear systems faster and more efficient, \nespecially for large matrices.\n\n\n::: {.content-visible when-profile=\"web\"}\n### QR decomposition\n:::\n\n::: {.content-visible when-profile=\"slides\"}\n## QR factorization\n:::\n\nA QR decomposition of a square matrix $A\\in\\mathbb{R}^{n\\times n}$ is a factorization of $A$ into a product of matrices\n\n$$\nA=QR,\n$$\nwhere $Q$ is an orthogonal square matrix and $R$ is an upper-triangular square matrix.\n\n\nQR factorization is useful in solving linear systems and performing least squares fitting.\n\n<br>\nThis factorization has a couple of important benefits:\n\n1. **Solving Linear Systems**: When you're working with a system of equations represented by $A\\mathbf{x} = \\mathbf{b}$, you can substitute the QR factorization into this equation:\n\n   $$\n   QR\\mathbf{x} = \\mathbf{b}\n   $$\n\n   Since $Q$ is orthogonal, you can multiply both sides by $Q^T$ (the transpose of $Q$) to simplify it:\n\n   $$\n   R\\mathbf{x} = Q^T\\mathbf{b}\n   $$\n\n   Now, you can solve this upper triangular system for $\\mathbf{x}$ using backward substitution, which is typically easier and more stable.\n\n2. **Least Squares Problems**: In many data science applications, you want to find the best fit line or hyperplane for your data. QR factorization is particularly useful here because it helps in minimizing the error when the system is overdetermined (more equations than unknowns). You can solve the least squares problem by leveraging the QR decomposition to find:\n\n   $$\n   \\hat{\\mathbf{x}} = R^{-1}Q^T\\mathbf{b}\n   $$\n\nBy converting the problem into a triangular system, QR factorization often provides a more stable numerical solution than other methods, especially for poorly conditioned matrices.\n\n\n\n\n::: {.content-visible when-profile=\"web\"}\n### Eigendecomposition\n:::\n\n::: {.content-visible when-profile=\"slides\"}\n## Eigendecomposition\n:::\n\nLet $A\\in\\mathbb{R}^{n\\times n}$ have $n$ linearly independent eigenvectors $\\mathbf{x}_i$ for $i=1,\\ldots, n$, then $A$ can be factorized as\n\n$$\nA = X\\Lambda X^{-1},\n$$\n\nwhere the columns of matrix $X$ are the eigenvectors of $A$, and \n\n$$\n\\Lambda =\n\\begin{bmatrix}\n\\lambda_{1} & 0 & \\cdots & 0 \\\\\n0 & \\lambda_{2} & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n0 & 0 & \\cdots & \\lambda_{n}  \\\\\n\\end{bmatrix},\n$$\n\nis a diagonal matrix of the eigenvalues. \n\nIn this case, the matrix $A$ is said to be diagonalizable.\n\n<br>\nInstead of calulating $A\\mathbf{x}$ directly, we can map it by first\ntransforming it using $X^{-1}$ and then stretching it by $\\Lambda$ and finally\ntransforming it using $X$.\n\n$$\nA \\mathbf{x} = X \\Lambda X^{-1} \\mathbf{x}\n$$\n\nWe'll use eigendecomposition in Principal Component Analysis (PCA) to reduce dimensionality in datasets while preserving as much variance as possible.\n\n::: {.content-visible when-profile=\"slides\"}\n## Spectral decomposition\n:::\nA special case occurs when $A$ is symmetric. Recall that a matrix is symmetric when $A = A^T.$\n\nIn this case, it can be shown that the eigenvectors of $A$ are all mutually orthogonal. Consequently, $X^{-1} = X^{T}$ and we can decompose $A$ as:\n\n$$A = XDX^T.$$\n\nThis is known as the spectral theorem and this decomposition of $A$ is its spectral decomposition. The eigenvalues of a matrix are also called its spectrum.\n\n\n::: {.content-visible when-profile=\"web\"}\n### Singular value decomposition\n:::\n\n::: {.content-visible when-profile=\"slides\"}\n## Singular value decomposition\n:::\n\nFor the previous few examples, we required $\\mathbf{A}$ to be square. Now\nlet $A\\in\\mathbb{R}^{m\\times n}$ with $m>n$, then $A$ admits a decomposition\n\n$$\nA = U\\Sigma V^{T}.\n$$\nThe matrices $U\\in\\mathbb{R}^{m\\times m}$ and $V\\in\\mathbb{R}^{n\\times n}$ are orthogonal. The columns of $U$ are the left singular vectors and the columns of $V$ are the right singular vectors.\n\nThe matrix $\\Sigma\\in\\mathbb{R}^{m\\times n}$ is a diagonal matrix of the form\n\n$$\n\\Sigma = \n\\begin{bmatrix}\n\\sigma_{11} & 0 & \\cdots & 0 \\\\\n0 & \\sigma_{22} & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n0 & 0 & \\cdots & \\sigma_{mn} \\\\\n\\end{bmatrix}.\n$$\n\nThe values $\\sigma_{ij}$ are the singular values of the matrix $A$. \n\nAmazingly, it can be proven that every matrix $A\\in\\mathbb{R}^{m\\times n}$ has a singular value decomposition.\n\n\n# Linear Systems and Least Squares\n\n## Linear systems of equations\n\nA system of $m$ linear equations in $n$ unknowns can be written as\n\n$$\n\\begin{align*}\na_{11} x_{1} + a_{12} x_{2} + \\cdots + a_{1n} x_{n} &= b_1, \\\\\na_{21} x_{1} + a_{22} x_{2} + \\cdots + a_{2n} x_{n} &= b_2, \\\\\n\\vdots  \\qquad \\qquad \\quad \\\\\na_{m1} x_{1} + a_{m2} x_{2} + \\cdots + a_{mn} x_{n} &= b_m.\\\\\n\\end{align*}\n$$\n\nObserve that this is simply the matrix vector equation\n\n$$\nA\\mathbf{x}=\\mathbf{b}.\n$$\n\n$$\nA\\mathbf{x} = \n\\begin{bmatrix}\na_{11} & a_{12} & \\cdots & a_{1n} \\\\\na_{21} & a_{22} & \\cdots & a_{2n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{m1} & a_{m2} & \\cdots & a_{mn} \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nx_1 \\\\\nx_2 \\\\\n\\vdots \\\\\nx_n\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nb_1 \\\\\nb_2 \\\\\n\\vdots \\\\\nb_m\n\\end{bmatrix}.\n$$\n\n::: {.content-visible when-profile=\"slides\"}\n## Linear systems of equations continued\n:::\n\nA linear system of equations may have:\n\n:::: {.incremental}\n- infinitely many solutions,\n- a unique solution,\n- no solutions.\n::::\n\n:::: {.fragment}\nWhen $m > n$, the system is said to be overdetermined and _in general_ has no  solutions. When $m < n$ the system is underdetermined and _in general_ has infinitely many solutions. For the case when $m=n$ and the matrix has $n$ linearly dependent columns, the solution is always unique.\n\nFor an invertible square matrix $A\\mathbf{x}=\\mathbf{b}$, the solution is always $\\mathbf{x}=A^{-1}\\mathbf{b}$. \n::::\n\n::: {.content-visible when-profile=\"slides\"}\n## Linear systems of equations continued\n:::\nWe can use matrix factorizations to help us solve a linear system of equation. We demonstrate how to do this with the LU decomposition. Observe that \n$$A\\mathbf{x} = LU\\mathbf{x} = \\mathbf{b}.$$ \n\nThen \n\n$$\n\\mathbf{x} = U^{-1}L^{-1}\\mathbf{b}.\n$$ \n\nThe process of inverting $L$ and $U$ is called backward and forward substitution.\n\n\n## Least squares\n\nIn data science it is often the case that we have to solve the linear system \n\n$$\nA \\mathbf{x} = \\mathbf{b}.\n$$ \n\nThis problem may have no solution -- perhaps due to noise or measurement error.\n\nIn such a case, we look for a vector $\\mathbf{x}$ such that $A\\mathbf{x}$ is a good approximation to $\\mathbf{b}.$\n\nThe quality of the approximation can be measured using the distance from $A\\mathbf{x}$ to $\\mathbf{b},$ i.e.,\n\n$$\n\\Vert A\\mathbf{x} - \\mathbf{b}\\Vert_2.\n$$\n\n::: {.content-visible when-profile=\"slides\"}\n## Least squares continued\n:::\nThe general least-squares problem is given $A\\in\\mathbb{R}^{m\\times n}$ and and $\\mathbf{b}\\in\\mathbb{R}^{m}$, find a vector $\\hat{\\mathbf{x}}\\in\\mathbb{R}^{n}$ such that $\\Vert A\\mathbf{x}-\\mathbf{b}\\Vert_2$ is minimized, i.e. \n\n$$\n\\hat{\\mathbf{x}} = \\arg\\min_\\mathbf{x} \\Vert A\\mathbf{x} - \\mathbf{b}\\Vert.\n$$\n\nThis emphasizes the fact that the least squares problem is a minimization problem.\n\n::: {.content-visible when-profile=\"web\"}\nMinimizations problems are an example of a broad class of problems called _optimization_ problems. In optimization problems we attempt to find an optimal solution that minimizes (or maximizes) a set particular set of equations (and possibly constraints). \n:::\n\n::: {.content-visible when-profile=\"slides\"}\n## Least squares continued\n:::\nWe can connect the above minimization of the distance between vectors to the minimization of the sum of squared errors. Let $\\mathbf{y} = A\\mathbf{x}$ and observe that\n\n$$\\Vert A\\mathbf{x}-\\mathbf{b}\\Vert_2^2 = \\Vert \\mathbf{y}-\\mathbf{b}\\Vert_2^2 =  \\sum_i (y_i-b_i)^2.$$\n\n::: {.content-visible when-profile=\"web\"}\nThe above expression is the sum of squared errors. In statistics, the $y_i$ are the estimated values and the $b_i$ are the measured values. This is the most common measure of error used in statistics and is a key principle. \n:::\n\nMinimizing the length of $A\\mathbf{x} - \\mathbf{b}$ is equivalent to minimizing the sum of the squared errors. \n\n::: {.content-visible when-profile=\"slides\"}\n## Least squares continued\n:::\nWe can find $\\hat{\\mathbf{x}}$ using either \n\n:::: {.incremental}\n* geometric arguments based on projections of the vector $\\mathbf{b}$,\n* by calculus (taking the derivative of the right-hand-side expression above and setting it equal to zero).\n::::\n\n:::: {.fragment}\nEither way, we obtain the result that $\\hat{\\mathbf{x}}$ is the solution of:\n    \n$$A^TA\\mathbf{x} = A^T\\mathbf{b}.$$\n\nThis system of equations is called the normal equations.\n::::\n\n::: {.content-visible when-profile=\"slides\"}\n## Least squares continued\n:::\nWe can prove that these equations always have at least one solution. \n\nWhen $A^TA$ is invertible, the system is said to be overdetermined. This means that there is a unique solution\n\n$$\\hat{\\mathbf{x}} = (A^TA)^{-1}A^T\\mathbf{b}.$$\n\n\n::: {.content-visible when-profile=\"slides\"}\n## Least squares beware\n:::\nBe aware that computing the solution using $(A^TA)^{-1}A^T$ can be numerically unstable. A more stable method is to use the QR decomposition of $A$, i.e., $\\hat{\\mathbf{x}} = R^{-1}Q^T\\mathbf{b}$. \n\nThe NumPy function `np.linalg.lstsq()` solves the least squares problem in a stable way. \n\nConsider the following example where the solution to the least squares problem is `x=np.array([1, 1])`.\n\n::: {#4770bd28 .cell execution_count=6}\n``` {.python .cell-code code-fold=\"false\"}\nimport numpy as np\nA = np.array([[-1.42382504, -1.4238264 ],\n              [ 1.26372846,  1.26372911], \n              [-0.87066174, -0.87066138]])\nb = A @ np.array([1, 1])\n\n# Pseudoinverse\nx1 = np.linalg.inv(A.T @ A) @ A.T @ b\nprint(x1)\n# QR\n[Q, R] = np.linalg.qr(A)\nx2 = np.linalg.solve(R, Q.T @ b)\nprint(x2)\n# np.linalg.lstsq\nx3, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\nprint(x3) \nprint(np.linalg.norm(x1-np.array([1, 1])))\nprint(np.linalg.norm(x2-np.array([1, 1])))\nprint(np.linalg.norm(x3-np.array([1, 1])))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1.00010437 0.99918931]\n[1. 1.]\n[1. 1.]\n0.0008173802348693703\n1.3212084675495204e-10\n4.1498941065303375e-10\n```\n:::\n:::\n\n\n::: {.content-visible when-profile=\"slides\"}\n\n# Recap\n\n## Recap\n\nWe have introduced the following concepts:\n\n- vectors,\n- matrices,\n- matrix multiplication,\n- matrix decompositions,\n- linear systems of equations,\n- least squares,\n- eigenvalues and eigenvectors.\n:::\n\n",
    "supporting": [
      "04-Linear-Algebra-Refresher_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}