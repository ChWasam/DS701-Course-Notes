{
  "hash": "305b807e20a6a565c22859b58e678531",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Decision Trees\njupyter: python3\n---\n\n\n## Introduction\n\n[![](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/tools4ds/DS701-Course-Notes/blob/main/ds701_book/jupyter_notebooks/14-Classification-I-Decision-Trees.ipynb)\n\nWe start our study of __classification__ methods.\n\n::: {.fragment}\nRecall that in a classification problem, we have data tuples $(\\mathbf{x}, y)$ in which the $\\mathbf{x}$ are the features, and the $y$ values are __categorical__ data.  \n\nWe typically call the $y$ values \"labels\" or \"classes.\"\n:::\n\n:::: {.fragment}\nSome examples of classification tasks:\n\n* Predicting tumor cells as malignant or benign\n* Classifying credit card transactions as legitimate or fraudulent\n* Classifying secondary structures of a protein as alpha-helix, beta-sheet, or other\n* Categorizing news stories as finance, weather, entertainment, sports, etc\n::::\n\n---\n\nThe first classification method we will consider is called the __decision tree.__\n\nIt is a __very__ popular method, and has some nice properties as we will see.\n\n## Decision Trees in Action\n\n::: {.callout-note}\nThis section and a number of following sections are based on Chapter 4 of \"Introduction to Data Mining,\" by Tan, Steinbach, and Kumar (2004) and companion slides.\n:::\n\nWe will start by describing how a decision tree works.\n\nWe are assuming a decision tree has been built to solve the following classification problem:\n\nGiven an individual's Tax Refund Status, Marital Status, and Taxable Income, predict whether they will repay a loan.\n\n![](figs/L14-DT-Example-1.png){width=\"800px\"}\n\n---\n\nWe then step through the tree, making a decision at each node that takes us to another node in the tree.\n\nEach decision examines a single feature in the item being classified.\n\n![](figs/L14-DT-Example-2.png){width=\"800px\"}\n\n---\n\n![](figs/L14-DT-Example-3.png){width=\"800px\"}\n\n---\n\n![](figs/L14-DT-Example-4.png){width=\"800px\"}\n\n---\n\n![](figs/L14-DT-Example-5.png){width=\"800px\"}\n\n---\n\n![](figs/L14-DT-Example-6.png){width=\"800px\"}\n\nWe conclude that this record is classified as \"Not Repay\" is \"No\".\n\n---\n\nNote also that decision trees can be used to predict numeric values, so they are used for regression as well.\n\nThe general term \"Classification and Regression Tree\" (CART) is sometimes used -- although this term also refers to a specific decision tree learning algorithm.\n\n## Learning a Decision Tree\n\n![](figs/L14-DT-Overview.png){width=\"800px\"}\n\nWe've discussed how to apply a decision tree to data (lower portion of this figure).\n\nBut how does one train a decision tree?   What algorithm can we use?\n\n---\n\nA number of algorithms have been proposed for building decision trees:\n\n* Hunt's algorithm (one of the earliest)\n* CART\n* ID3, C4.5\n* SLIQ, SPRINT\n* etc\n\nWe will look at Hunt's Algorithm as our example.\n\n## Hunt's Algorithm\n\nHunt's Algorithm builds the tree node by node, starting from the root.\n\nAs we build the tree, we divide the training data up.\n\n:::: {.columns}\n::: {.column width=\"55%\"}\nLet $D_t$ be the set of training records that reach node $t$.\n    \n * If $D_t$ contains records that all belong to a single class $y_t$, then $t$ is a leaf node labeled as $y_t$.\n * If $D_t$ is an empty set, then $t$ is a leaf node labeled by the default class $y_d$.\n * If $D_t$ contains records that belong to more than one class, use an attribute to split $D_t$ into smaller subsets, and assign that splitting-rule to node $t$.\n    \nRecursively apply the above procedure until a stopping criterion is met.\n\n:::\n::: {.column width=\"40%\"}\n\n![](figs/L14-DT-Data-Example.png) \n\n:::\n::::\n\n---\n\nSo as Hunt's algorithm progresses, records are divided up and assigned to leaf nodes.   The most challenging step in Hunt's algorithm is deciding which leaf node to split next, and how to specify the split.\n\nIn general, we use a greedy strategy.  We will split a set of records based on an attribute test that optimizes some criterion.\n\nWe choose the set to split that provides the __largest improvement in our criterion.__\n\nOnce we have chosen the set to split, the remaining questions are:\n    \n* Determining how to split the record set\n    * How should we specify the attribute test condition?\n    * How should we determine the best split for a set based on a given attribute?\n* Determining when to stop splitting.\n\n## Specifying the Test Condition\n\nHow we specify a test condition depends on the attribute type:\n\n* Nominal (Categorical)\n* Ordinal (eg, Small, Medium, Large)\n* Continuous\n\nAnd depends on the number of ways to split - __multi-way__ or __binary__:\n\n---\n\nFor a __Nominal__ attribute:\n\nIn a __Multi-way split__ we can use as many partitions as there are distinct values of the attribute:\n\n![](figs/L14-split-1.png){width=\"300px\"}\n\n---\n\nIn a __Binary split__ we divide the values into two groups.  \n\nIn this case, we need to find an optimal partitioning of values into groups.\n\n![](figs/L14-split-2.png){width=\"600px\"}\n\n---\n\nAn __Ordinal__ attribute is similar to a Nominal attribute, except that since\nattributes have an ordering, we can specify the test in terms of a threshold.  \n\nThis simplifies the search for a good paritition.\n\n![](figs/L14-split-3.png){width=\"600px\"}\n\n---\n\nA __Continuous__ attribute can be handled two ways:\n    \nIt can be __discretized__ to form an ordinal categorical attribute\n\n![](figs/L14-split-4.png){width=\"400px\"}\n\nOr it can be partitioned via a threshold to form for a binary split.\n\n![](figs/L14-split-5.png){width=\"200px\"}\n\n---\n\nNote that finding good partitions for nominal attributes can be expensive, \npossibly involving combinatorial searching of groupings.  \n\nHowever for ordinal or continuous attributes, sweeping through a range of\nthreshold values can be more efficient.\n\n## Determining the Best Split\n\nOur algorithmic strategy is to split record sets so as to improve classification\naccuracy on the training data.\n\nWhen is classification accuracy maximized?   \n\n::: {.callout-important}\nWhen each leaf node contains records that all have the same label.\n:::\n\n---\n\n![](figs/L14-split-6.png){width=\"700px\"}\n\nConsider this case:\n    \nAt some node in the tree, before splitting that node's records, we have\n\n* 10 records from class 0, and\n* 10 records from class 1\n\nThere are three attributes we can split on.   Which split is best?\n\n---\n\n::: {.content-visible when-profile=\"slides\"}\n![](figs/L14-split-6.png){width=\"700px\"}\n:::\n\nThe \"Car Type\" attribute yields more homogeneous splits.\n\nUsing the \"Student ID\" attribute yields perfect accuracy on the training data.\n\n... but what would it do on the test data?\n\n... using the \"Student ID\" attribute would lead to __overfitting__\n\nWe'll talk about how to avoid overfitting shortly.\n\n---\n\nFor now, let's just focus on maximizing the homogeneity of splits.\n\nWe need a measure of homogeneity:\n\n![](figs/L14-split-7.png){width=\"700px\"}\n\nA number of measures have been proposed:\n\n* GINI Index\n* Entropy\n* Misclassification Error\n\nWe will review GINI, as it is a typical measure. \n\nIt's used, for example, in CART, SLIQ, and SPRINT.\n\n## Computing GINI\n\nWe will think of the set of records at each node as defining a distribution over the classes. \n\nFor a given node $t$, we will use $p(j\\,|\\,t)$ to denote the frequency of class $j$ at node $t$.\n\nThe GINI coefficient measures the degree of \"balance\" in a distribution.\n\nIt is defined as:\n\n$$\n\\text{GINI}(t) = 1 - \\sum_j [p(j\\,|\\,t)]^2\n$$\n\n---\n\nAs nodes are split in building the tree, we will be decreasing the GINI score.\n\n![](figs/L14-GINI-1.png){width=\"80%\"}\n\n---\n\nHow do we compute the improvement in GINI when a node is split?\n\nRemember that we would like to create large, homogeneous nodes.\n\nSo we will weight each node's GINI score by the number of records it contains. \n\nSo the improvement in GINI score when splitting a node $t$ with $n$ records will be computed as:\n    \n$$\n\\text{GINI}_{\\text{new}} = \\sum_i \\frac{n_i}{n}\\; \\text{GINI}(i)\n$$\n\nwhere new node $i$ contains $n_i$ records;\n\nand the improvement in GINI score will be defined as\n\n$$\n\\text{GINI}(t) - \\text{GINI}_{\\text{new}}\n$$\n\n## GINI for Binary Partitions\n\nHere is an example of computing the new GINI score for a partition:\n    \n![](figs/L14-GINI-2.png){width=\"80%\"}\n\n## GINI for Nominal Attributes\n\n* For each distinct value, gather counts for each class in the dataset\n* Use the count matrix to evaluate groupings\n\n![](figs/L14-GINI-3.png){width=\"80%\"}\n\n## GINI for Continuous Attributes\n\nTo find the best threshold efficiently:\n* Sort the attribute on values\n* Linearly scan the values, \n    * each time updating a count matrix and\n    * computing the new GINI score\n* Choose the split position with the smallest GINI index\n\n![](figs/L14-GINI-4.png){width=\"80%\"}\n\n## When to Stop Splitting\n\nWe now see how the decision tree is built, node by node, by splitting nodes in a\nway that steadily improves the overall GINI score.\n\nClearly, we could keep on splitting nodes until every leaf node contains only\nunique training records.\n\nFor example, each leaf node could contain just a single training record - a\nfully-grown tree.\n\nThis would certainly be overfitting! \n\nWe would have as many leaf nodes (parameters) as training data records.\n\nAnd we would not expect the decision tree to generalize well.\n\n---\n\nThere are two strategies that can be used to control the complexity of a decision tree:\n\n1. Early-stopping: stop the algorithm before the tree becomes fully-grown \n2. Post-pruning: grow decision tree fully, then prune nodes from leaves upward\n\n## Early Stopping\n\nDo not expand the current node, even though it still has multiple records.\n\nDefault stopping conditions include:\n\n* Stop if all records belong to the same class\n* Stop if all the records have the same attributes\n\nMore restrictive stopping conditions include:\n\n* Stop if number of records in current node is less than a specified value\n* Stop if expanding the current node does not improve homogeneity (eg, GINI score)\n* Stop if splitting current node would create node smaller than a specified value\n\n## Post-Pruning\n\nAssumes that we can assess generalization error \n\n* For example, using held-out data\n\nThen:\n\n* Grow decision tree to its entirety\n* Trim the nodes of the tree in bottom-up fashion\n    * Replace nodes with majority class\n* If generalization error improves after trimming, replace sub-tree by a leaf node\n\nNote that this is computationally more demanding than early-stopping.\n\n## Interpretability\n\nDecision Trees are a very popular technique.  \n\nThey have a number of advantages:\n\n* They are relatively inexpensive to construct\n* They are extremely fast at classifying unknown data\n* Their accuracy can be quite good in many cases\n* And oftentimes they are __interpretable__\n\nWe will explore interpretation of decision trees in a following lecture.\n\n## Recap\n\n* Classification: predicting a nominal or categorical variable\n* Decision Trees: a popular classification method\n* Hunt's algorithm: a simple decision tree algorithm\n* Greedy strategy: split node with largest information gain\n* Overfitting: when a model matches the training data too closely\n* Early stopping: stop splitting when a criterion is met\n* Post-pruning: grow tree fully, then prune\n\n",
    "supporting": [
      "14-Classification-I-Decision-Trees_files"
    ],
    "filters": [],
    "includes": {}
  }
}