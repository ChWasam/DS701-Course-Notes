{
  "hash": "9f70c5a278fe0306cf4f2557dee59736",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'NN II -- Compute Graph, Backprop and Training'\njupyter: python3\n---\n\n\n\n\n[![](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/tools4ds/DS701-Course-Notes/blob/main/ds701_book/jupyter_notebooks/24-NN-II-Backprop.ipynb)\n\n\nIn this lecture we'll gradually build out a light weight neural network training framework reminiscent of PyTorch.\n\nWe build:\n* A simple neural network engine we call `Value` class that wraps numbers and math operators and includes useful attributes and methods for implementing _forward pass_ and _back propagation_. _(~63 lines of code)_\n\nWe'll provide (and explain)\n* A simple _compute graph_ visualization function. _(34 lines of code)_\n* A small set of helper functions that easily define a neuron, layer and multi-layer perceptron (MLP). _(84 lines of code)_\n\nWith that we can implement a neural network training loop, and see how similar it is to a PyTorch implementation.\n\n\nThe code is based on Andrej Karpathy's [micrograd](https://github.com/karpathy/micrograd).\n\n## Neuron and Neural Networks (Recap)\n\nNow let's switch gears a bit to define an _artificial neuron_. For better or worse\nit is named after and loosely modeled on a biological neuron.\n\n<!-- Image Credit \"https://cs231n.github.io/neural-networks-1/\"-->\n\n<center>\n    \n<img src=\"figs/NN-figs/neuron.png\" width=\"75%\">\n    \n</center> \n\nFrom [cs231n](https://cs231n.github.io/neural-networks-1/)\n\n* The dendrites carry impulses from other neurons of different distances.\n* Once the collective firing rate of the impulses exceed a certain threshold, the neuron fires its own pulse through the axon to other neurons\n\nThere are companies trying to mimic this impulse (i.e. spiking) based neuron in silicon -- so called _neuromorphic computing_.\n\nSee for example [Neuromorphic Computing](https://en.wikipedia.org/wiki/Neuromorphic_engineering) or [Spiking Neural Network](https://en.wikipedia.org/wiki/Spiking_neural_network)\n\nSome examples of companies and projects are Intel's [Loihi](https://www.intel.com/content/www/us/en/research/neuromorphic-computing-loihi-2-technology-brief.html) and startups such as GrAI Matter Labs [VIP processor](https://www.graimatterlabs.ai/product).\n\n### Artificial Neuron\n\n<!-- Image Credit \"https://cs231n.github.io/neural-networks-1/\"-->\n\n<center>\n    \n<img src=\"figs/NN-figs/neuron_model.jpeg\" width=\"75%\">\n    \n</center> \n\nFrom [cs231n](https://cs231n.github.io/neural-networks-1/)\n\nThe more common artifical neuron \n* collects one or more inputs, \n* each multiplied by a unique weight\n* sums the weighted inputs\n* adds a bias\n* then finally usually applies a nonlinear activation function\n\n### Relating Back to Earlier Lectures\n\n__Question__\n\nWhat does \n\n$$\\sum_i w_i x_i + b$$\n\nremind you of?\n\n__Answer__\n\nHow about multiple regression in the Linear Regression lecture?\n\n$$y = \\beta_0 + \\beta_1 u + \\beta_2 v$$\n\nWe just renamed things: $\\beta_0 \\gets b$, $\\beta_1 \\gets w_0$, $\\beta_2 \\gets w_1$, $u \\gets x_0$ and $v \\gets x_1$ for $i \\in [0,1]$.\n\n> So multiple linear regression can be viewed as one linear neuron.\n\nActivation function is typically some nonlinear function that compresses the input in some way. Historically, it's been the sigmoid and $\\tanh()$ functions. See for example [Hyperbolic Functions](https://en.wikipedia.org/wiki/Hyperbolic_functions#Tanh).\n\n::: {#16cdac28 .cell hide_input='true' tags='[\"hide-input\"]' execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef sigmoid(x):\n    return 1 / (1 + np.exp(-x))\n\nx = np.linspace(-10, 10, 100)\ny = sigmoid(x)\n\nplt.plot(x, y)\nplt.title('Sigmoid function')\nplt.xlabel('x')\nplt.ylabel('sigmoid(x)')\nplt.grid(True)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](24-NN-II-Backprop_files/figure-html/cell-3-output-1.png){width=589 height=449}\n:::\n:::\n\n\nThe hyperbolic tangent, $\\tanh$, is basically the sigmoid function shifted and scaled to a range of [-1,1].\n\n::: {#ccc9b7ce .cell hide_input='true' tags='[\"hide-input\"]' execution_count=3}\n``` {.python .cell-code}\nplt.plot(np.arange(-5,5,0.2), np.tanh(np.arange(-5,5,0.2)))\nplt.title('tanh(x)')\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.grid()\n```\n\n::: {.cell-output .cell-output-display}\n![](24-NN-II-Backprop_files/figure-html/cell-4-output-1.png){width=608 height=449}\n:::\n:::\n\n\nA more common activation function these days and that is more efficient to implement is the _Rectified Linear Unit_ or _ReLU_.\n\n$$ \\textrm{ReLU}(x) = \\mathrm{max}(0, x) $$\n\n::: {#723da800 .cell hide_input='true' tags='[\"hide-input\"]' execution_count=4}\n``` {.python .cell-code}\nplt.plot(np.arange(-5,5,0.2), np.maximum(0,np.arange(-5,5,0.2)))\nplt.title('ReLU(x)')\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.grid()\n```\n\n::: {.cell-output .cell-output-display}\n![](24-NN-II-Backprop_files/figure-html/cell-5-output-1.png){width=576 height=449}\n:::\n:::\n\n\nThere are many other variations. See for example [PyTorch Non-linear Activations](https://pytorch.org/docs/stable/nn.html#non-linear-activations-weighted-sum-nonlinearity)\n\n### Relating Back to _Another_ Earlier Lecture\n\n__Question__\n\nWhat does \n\n$$ \\mathrm{sigmoid}(\\sum_i w_i x_i + b) \\hspace{10pt} \\textrm{where} \\hspace{10pt} \\mathrm{sigmoid}(x) = \\frac{1}{1 + e^{-x}}$$\n\nremind you of?\n\n__Answer__\n\nHow about the Logistic Regression model?\n\n$$\n\\begin{split}\nP(y=1\\mid x) & = \\frac{e^{\\alpha+\\beta x}}{1+e^{\\alpha+\\beta x}}\\\\\n             & = \\frac{e^{\\alpha+\\beta x}}{1+e^{\\alpha+\\beta x}} \\left( \\frac{e^{-(\\alpha+\\beta x)}}{e^{-(\\alpha+\\beta x)}} \\right) \\\\\n             & = \\frac{e^{(\\alpha+\\beta x)-(\\alpha+\\beta x)}}{e^{-(\\alpha+\\beta x)}+e^{(\\alpha+\\beta x)-(\\alpha+\\beta x)}} \\\\\n             & = \\frac{e^0}{e^{-(\\alpha+\\beta x)} + e^0} \\\\\n             & = \\frac{1}{1 + e^{-(\\alpha+\\beta x)}}\n\\end{split}\n$$\n\nWhich is the Sigmoid with $\\alpha = 0$ and $\\beta = 1$.\n\nIn fact, just like in Logistic Regression, we use the sigmoid function on the last layer of a neural network that is\ndoing binary classification to output the probabilities.\n\n> So Logistic Regression is similar to one neuron with a sigmoid activation function.\n\n::: {#688dc348 .cell hide_input='true' slideshow='{\"slide_type\":\"subslide\"}' tags='[\"hide-input\"]' execution_count=5}\n``` {.python .cell-code}\nalphas = [-4, -8,-12,-20, 0]\nbetas = [0.4,0.4,0.6,1, 1]\nx = np.arange(-10,35)\nfig = plt.figure(figsize=(8, 6)) \nax = plt.subplot(111)\n\nfor i in range(len(alphas)):\n    a = alphas[i]\n    b = betas[i]\n    y = np.exp(a+b*x)/(1+np.exp(a+b*x))\n    ax.plot(x,y,label=r\"$\\alpha=%d,$    $\\beta=%3.1f$\" % (a,b))\n\nax.tick_params(labelsize=12)\nax.set_xlabel('x', fontsize = 14)\nax.set_ylabel('$p(x)$', fontsize = 14)\nax.legend(loc='center left', bbox_to_anchor=(1, 0.5), prop={'size': 16})\nax.set_title('Logistic Functions', fontsize = 16);\n```\n\n::: {.cell-output .cell-output-display}\n![](24-NN-II-Backprop_files/figure-html/cell-6-output-1.png){width=967 height=536}\n:::\n:::\n\n\n### Multi-Layer Perceptron (MLP) or Fully Connected Network (FCN)\n\n<center>\n    \n<img src=\"figs/NN-figs/neural_net2.jpeg\" width=\"75%\">\n    \n</center>\n\n\nFrom [cs231n](https://cs231n.github.io/convolutional-networks/)\n\nMultiple artificial neurons can be acting on the same inputs, in what we call\na _layer_, and we can have more than one _layer_ until we produce one or more\noutputs.\n\nThe example above shows a network with _3 inputs_, two layers of neurons, each\nwith 4 neurons, followed by one layer that produces a single value output.\n\nE.g. a binary classifier.\n\n## Computation Graph\n\nThe way we are going to differentiate more complex functions is to first build a \"computation graph\" to apply our operations on. We'll see that it breaks down the process into simple steps that easily scale to large networks.\n\nIt's the concept employed by TensorFlow and PyTorch, and in fact we'll follow PyTorch interface definition.\n\n### Building the `Value` Class\n\nTo do that we will build a data wrapper as a `class` called `Value` and gradually build in on all the functionality we need to define a Multi-Layer Neural Network (a.k.a. Multi-Layer Perceptron) and train it.\n\nFirst, the class has only a simple initialization method and a representation method.\n\n::: {#d827e1cf .cell slideshow='{\"slide_type\":\"subslide\"}' execution_count=6}\n``` {.python .cell-code}\n# Value version 1\nclass Value:\n\n    def __init__(self, data):\n        self.data = data\n\n    def __repr__(self):\n        \"\"\"Return a string representation of the object for display\"\"\"\n        return f\"Value(data={self.data})\"\n```\n:::\n\n\n::: {#3bf63e4d .cell execution_count=7}\n``` {.python .cell-code}\na = Value(4.0)\na\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nValue(data=4.0)\n```\n:::\n:::\n\n\nIf you are not familiar with [python classes](https://docs.python.org/3/tutorial/classes.html), there are a few things to note here.\n1. The property `self` is just a pointer to the object itself.\n2. The `__init__` method is called when you initialize a class object\n3. The `__repr__` method is how you represent the class object\n\n### Implementing Addition\n\nSo the Value object doesn't do much yet except for taking a value and printing it. We'd also like to do things like addition and other operations with them, but...\n\n::: {#424e544c .cell execution_count=8}\n``` {.python .cell-code}\na = Value(4.0)\nb = Value(-3.0)\n\ntry:\n    a+b \nexcept Exception as e:\n    print(\"Uh oh!\", e)\nelse:\n    print(\"It worked!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUh oh! unsupported operand type(s) for +: 'Value' and 'Value'\n```\n:::\n:::\n\n\nWhen python tries to add two objects `a` and `b`, internally it will call\n`a.__add__(b)`. So we have to add the `__add__()` method.\n\n::: {#d0720368 .cell execution_count=9}\n``` {.python .cell-code}\n# Value version 2\nclass Value:\n\n    def __init__(self, data):\n        self.data = data\n\n    def __repr__(self):\n        \"\"\"Return a string representation of the object for display\"\"\"\n        return f\"Value(data={self.data})\"\n\n    def __add__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data + other.data)\n        return out\n```\n:::\n\n\n::: {#5f9ac6ad .cell slideshow='{\"slide_type\":\"subslide\"}' execution_count=10}\n``` {.python .cell-code}\na = Value(4.0)\nb = Value(-3.0)\n\ntry:\n    a+b\nexcept Exception as e:\n    print(\"Uh oh!\", e)\nelse:\n    print(\"It worked!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIt worked!\n```\n:::\n:::\n\n\nWhich, as mentioned is equivalent to calling the `__add__` method on `a`.\n\n::: {#f6191ae2 .cell execution_count=11}\n``` {.python .cell-code}\na.__add__(b)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nValue(data=1.0)\n```\n:::\n:::\n\n\n### Implementing More Operations\n\nSimilarly we can support multiplication and implement a ReLU function as well.\n\n::: {#13007b37 .cell execution_count=12}\n``` {.python .cell-code}\nimport numpy as np\n\n# Value version 3\nclass Value:\n\n    def __init__(self, data):\n        self.data = data\n\n    def __repr__(self):\n        \"\"\"Return a string representation of the object for display\"\"\"\n        return f\"Value(data={self.data})\"\n\n    def __add__(self, other): # self + other\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data + other.data)\n        return out\n    \n    def __mul__(self, other): # self * other\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data * other.data)\n        return out\n    \n    def relu(self):\n        out = Value(np.maximum(0, self.data))\n        return out\n```\n:::\n\n\n::: {#eae0c388 .cell execution_count=13}\n``` {.python .cell-code}\na = Value(4.0)\nb = Value(-3.0)\nc = Value(8.0)\n\nd = a*b+c\nd\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\nValue(data=-4.0)\n```\n:::\n:::\n\n\n::: {#9274b42d .cell execution_count=14}\n``` {.python .cell-code}\nd.relu()\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\nValue(data=0.0)\n```\n:::\n:::\n\n\nBy the way, internally, python will call `__mul__` on `a`, then `__add__` on the temporary product object.\n\n::: {#e39840a6 .cell execution_count=15}\n``` {.python .cell-code}\n(a.__mul__(b)).__add__(c)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\nValue(data=-4.0)\n```\n:::\n:::\n\n\n### Child Nodes\n\nIn order to calculate the gradients, we will need to capture the computation graphs. To do that, we'll need to store pointers to the operands of each operation.\n\nTo start with, we'll accept a tuple of child nodes in the initializer and store that as a set in the object.\n\n::: {#466e2d03 .cell execution_count=16}\n``` {.python .cell-code}\n# Value version 4\nclass Value:\n                        #    vvvvvvvvvvvv\n    def __init__(self, data, _children=()):\n        self.data = data\n        self._prev = set(_children)\n\n    def __repr__(self):\n        \"\"\"Return a string representation of the object for display\"\"\"\n        return f\"Value(data={self.data})\"\n\n    def __add__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data + other.data, (self, other)) # store tuple of children\n        return out                        # ^^^^^^^^^^^^^\n    \n    def __mul__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data * other.data, (self, other)) # store tuple of children\n        return out                        # ^^^^^^^^^^^^^\n    \n    def relu(self):\n        out = Value(np.maximum(0, self.data), (self,))\n        return out                         #  ^^^^^^^\n```\n:::\n\n\n::: {#47dc31d5 .cell slideshow='{\"slide_type\":\"subslide\"}' execution_count=17}\n``` {.python .cell-code}\na = Value(4.0)\nb = Value(-3.0)\nc = Value(8.0)\n\nd = a*b\ne = d + c\n```\n:::\n\n\nWe can now see the children of the operands that produced the output value by printing the `_prev` value. The name `_prev` might not be intuitive yet, but it will make more sense when we view these operations as a graph.\n\n::: {#29db946b .cell execution_count=18}\n``` {.python .cell-code}\nd._prev\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n{Value(data=-3.0), Value(data=4.0)}\n```\n:::\n:::\n\n\n::: {#7a15c2f1 .cell execution_count=19}\n``` {.python .cell-code}\ne._prev\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n{Value(data=-12.0), Value(data=8.0)}\n```\n:::\n:::\n\n\n### Child Operations\n\nNow we've recorded pointers to the child nodes. It would be helpful to also record the operator used.\n\nWe'll also add labels for convenience.\n\n::: {#20d4f78a .cell execution_count=20}\n``` {.python .cell-code}\n# Value version 5\nclass Value:\n                                    #     vvvvvvv  vvvvvvvv\n    def __init__(self, data, _children=(), _op='', label=''):\n        self.data = data\n        self._prev = set(_children)\n        self._op = _op # store the operation that created this node\n        self.label = label # label for the node\n\n    def __repr__(self):\n        \"\"\"Return a string representation of the object for display\"\"\"\n        return f\"Value(data={self.data})\"\n\n    def __add__(self, other):\n        other = other if isinstance(other, Value) else Value(other)   \n        out = Value(self.data + other.data, (self, other), '+') # store tuple of children\n        return out                                      #  ^^^\n    \n    def __mul__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data * other.data, (self, other), '*') # store tuple of children\n        return out                                      #  ^^^\n    \n    def relu(self):                                 #  vvvvvv\n        out = Value(np.maximum(0, self.data), (self,), 'ReLU')\n        # out = Value(0 if self.data < 0 else self.data, (self,), 'ReLU')\n\n        return out\n```\n:::\n\n\n::: {#d27290db .cell execution_count=21}\n``` {.python .cell-code}\na = Value(4.0, label='a')\nb = Value(-3.0, label='b')\nc = Value(8.0, label='c')\n\nd = a*b ; d.label = 'd'\ne = d + c ; e.label = 'e'\n```\n:::\n\n\n::: {#f31eb3d9 .cell execution_count=22}\n``` {.python .cell-code}\nd._prev, d._op, d.label\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n({Value(data=-3.0), Value(data=4.0)}, '*', 'd')\n```\n:::\n:::\n\n\n::: {#08e4bfbc .cell execution_count=23}\n``` {.python .cell-code}\ne._prev, e._op, e.label\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n({Value(data=-12.0), Value(data=8.0)}, '+', 'e')\n```\n:::\n:::\n\n\n### The Compute Graph\n\nWe now have enough information stored about the compute graph to visualize it.\n\nThese are two functions to walk the graph and build sets of all nodes and edges (`trace`) and then draw them as a\ndirected graph (`draw_dot`).\n\n::: {#8031f749 .cell tags='[\"hide-input\"]' execution_count=24}\n``` {.python .cell-code}\n# draw_dot version 1\nfrom graphviz import Digraph\n\ndef trace(root):\n  # builds a set of all nodes and set of all edges in a graph\n  nodes, edges = set(), set()\n  def build(v):\n    if v not in nodes:\n      nodes.add(v)\n      for child in v._prev:\n        edges.add((child, v))\n        build(child)\n  build(root)\n  return nodes, edges\n\ndef draw_dot(root):\n  dot = Digraph(format='svg', graph_attr={'rankdir': 'LR'}) # LR = left to right\n\n  nodes, edges = trace(root)\n  for n in nodes:\n    uid = str(id(n))\n    # for any value in the graph, create a rectangular ('record') node for it\n    dot.node(name = uid, label = \"{ %s | data %.4f }\" % (n.label, n.data), shape='record')\n    if n._op:\n      # if this value is a result of some operation, create an op node for it\n      dot.node(name = uid + n._op, label = n._op)\n      # and connect this no de to it\n      dot.edge(uid + n._op, uid)\n\n  for n1, n2 in edges:\n    # connect n1 to the op node of n2\n    dot.edge(str(id(n1)), str(id(n2)) + n2._op)\n\n  return dot\n```\n:::\n\n\n::: {#da81362d .cell slideshow='{\"slide_type\":\"subslide\"}' execution_count=25}\n``` {.python .cell-code}\na = Value(4.0, label='a')\nb = Value(-3.0, label='b')\nc = Value(8.0, label='c')\n\nd = a*b ; d.label = 'd'\ne = d + c ; e.label = 'e'\n```\n:::\n\n\n::: {#120bc973 .cell slideshow='{\"slide_type\":\"-\"}' tags='[]' execution_count=26}\n``` {.python .cell-code}\ndraw_dot(e)\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n![](24-NN-II-Backprop_files/figure-html/cell-27-output-1.svg){}\n:::\n:::\n\n\nNote that every value object becomes a node in the graph. The operators are also represented as a kind of fake node so they can be visualized too.\n\n::: {#66b0b2a6 .cell tags='[]' execution_count=27}\n``` {.python .cell-code}\nnodes, edges = trace(e)\nprint(\"Nodes: \", nodes)\nprint(\"Edges: \", edges)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNodes:  {Value(data=-3.0), Value(data=8.0), Value(data=-12.0), Value(data=-4.0), Value(data=4.0)}\nEdges:  {(Value(data=-12.0), Value(data=-4.0)), (Value(data=4.0), Value(data=-12.0)), (Value(data=-3.0), Value(data=-12.0)), (Value(data=8.0), Value(data=-4.0))}\n```\n:::\n:::\n\n\nLets add one more operation, or stage in the compute graph.\n\n::: {#7aaa3811 .cell tags='[]' execution_count=28}\n``` {.python .cell-code}\na = Value(4.0, label='a')\nb = Value(-3.0, label='b')\nc = Value(8.0, label='c')\n\nd = a*b; d.label = 'd'\ne = d + c; e.label = 'e'\nf = Value(2.0, label='f')\n\nL = e*f; L.label = 'L'\n\ndraw_dot(L)\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n![](24-NN-II-Backprop_files/figure-html/cell-29-output-1.svg){}\n:::\n:::\n\n\n### Recap\n\nSo far we've built a Value class and associated data structures to capture a computational graph and calculate the output based on the inputs and operations. We'll call this the __forward pass__.\n\nBut now, we're interested in calculating the gradients with respect to some of the parameters with respect to $L$. \n\nSo next we'll update our Value class to capture the partial derivative at each node relative to L.\n\n## Calculating Gradients\n\nAdd a gradient member variable, `grad`, to our class.\n\n::: {#6c218521 .cell execution_count=29}\n``` {.python .cell-code}\n# Value version 6\nclass Value:\n\n    def __init__(self, data, _children=(), _op='', label=''):\n        self.data = data\n        self.grad = 0.0 # default to 0  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n        self._prev = set(_children)\n        self._op = _op # store the operation that created this node\n        self.label = label # label for the node\n\n    def __repr__(self):\n        \"\"\"Return a string representation of the object for display\"\"\"\n        return f\"Value(data={self.data})\"\n\n    def __add__(self, other):\n        other = other if isinstance(other, Value) else Value(other)   \n        out = Value(self.data + other.data, (self, other), '+') # store tuple of children\n        return out\n    \n    def __mul__(self, other):\n        other = other if isinstance(other, Value) else Value(other)   \n        out = Value(self.data * other.data, (self, other), '*') # store tuple of children\n        return out\n    \n    def relu(self):         \n        out = Value(np.maximum(0, self.data), (self,), 'ReLU')\n        # out = Value(0 if self.data < 0 else self.data, (self,), 'ReLU')\n\n        return out\n```\n:::\n\n\nAnd update `draw_dot()` to show `grad` in the node info.\n\n::: {#85444536 .cell tags='[]' execution_count=30}\n``` {.python .cell-code}\n# draw_dot version 2\nfrom graphviz import Digraph\n\ndef trace(root):\n  # builds a set of all nodes and set of all edges in a graph\n  nodes, edges = set(), set()\n  def build(v):\n    if v not in nodes:\n      nodes.add(v)\n      for child in v._prev:\n        edges.add((child, v))\n        build(child)\n  build(root)\n  return nodes, edges\n\ndef draw_dot(root):\n  dot = Digraph(format='svg', graph_attr={'rankdir': 'LR'}) # LR = left to right\n\n  nodes, edges = trace(root)\n  for n in nodes:\n    uid = str(id(n))\n    # for any value in the graph, create a rectangular ('record') node for it\n    dot.node(name = uid, label = \"{ %s | data %.4f | grad %.4f }\" % (n.label, n.data, n.grad), shape='record')\n    if n._op:\n      # if this value is a result of some operation, create an op node for it\n      dot.node(name = uid + n._op, label = n._op)\n      # and connect this node to it\n      dot.edge(uid + n._op, uid)\n\n  for n1, n2 in edges:\n    # connect n1 to the op node of n2\n    dot.edge(str(id(n1)), str(id(n2)) + n2._op)\n\n  return dot        \n```\n:::\n\n\nAnd reinitialize and redraw...\n\n::: {#935022c7 .cell slideshow='{\"slide_type\":\"-\"}' tags='[]' execution_count=31}\n``` {.python .cell-code}\na = Value(4.0, label='a')\nb = Value(-3.0, label='b')\nc = Value(8.0, label='c')\n\nd = a*b; d.label = 'd'\ne = d + c; e.label = 'e'\nf = Value(2.0, label='f')\n\nL = e*f; L.label = 'L'\n\ndraw_dot(L)\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n![](24-NN-II-Backprop_files/figure-html/cell-32-output-1.svg){}\n:::\n:::\n\n\n### Manual Gradient Calculation\n\nBefore we start implementing backpropagation, it is helpful to manually calculate some gradients to better understand the procedure.\n\nFor the node $L$, we trivially calculate $\\frac{dL}{dL} = 1$. \n\nFrom limit ratio perspective, \n\n$$ \\frac{\\partial L}{\\partial L} = \\lim_{h \\rightarrow 0} \\frac{ (L+h) - L }{h} = \\frac{h}{h} = 1$$\n\n::: {#6fb5dbc3 .cell tags='[]' execution_count=32}\n``` {.python .cell-code}\nL.grad = 1.0\n```\n:::\n\n\nIf we go backwards a step in the graph, we see that $L=e*f$, so we calculate\n\n$$\\frac{\\partial{L}}{\\partial{e}} = \\frac{\\partial}{\\partial{e}} (e\\times f) = f$$\n\nand\n\n$$\\frac{\\partial{L}}{\\partial{f}} = \\frac{\\partial}{\\partial{f}} (e\\times f) = e.$$\n\n::: {#8c9f9eda .cell tags='[]' execution_count=33}\n``` {.python .cell-code}\ne.grad = f.data\n```\n:::\n\n\n::: {#d1bc4e32 .cell tags='[]' execution_count=34}\n``` {.python .cell-code}\nf.grad = e.data\n```\n:::\n\n\n> To summarize, the partial derivative w.r.t. to one operand of a simple product is simply the other operand.\n\nAnd we can redraw the graph above again.\n\n::: {#1e738c63 .cell tags='[]' execution_count=35}\n``` {.python .cell-code}\ndraw_dot(L)\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n![](24-NN-II-Backprop_files/figure-html/cell-36-output-1.svg){}\n:::\n:::\n\n\nHow do the parameters $e$ and $f$ influence $L$?\n\n::: {#fa0ceacb .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=36}\n``` {.python .cell-code}\n# Try uncommenting `e += h` or `f += h` and calling `wiggle()` then `wiggle(1.0)`\n# to see the influence of e or f on L\ndef wiggle(h = 0.0):\n    a = Value(4.0, label='a')\n    b = Value(-3.0, label='b')\n    c = Value(8.0, label='c')\n\n    d = a*b; d.label = 'd'\n    e = d + c; e.label = 'e'\n    # e += h\n    f = Value(2.0, label='f')\n    f += h\n\n    L = e*f; L.label = 'L'\n    print(L)\n```\n:::\n\n\n::: {#dc9e80a8 .cell execution_count=37}\n``` {.python .cell-code}\nwiggle()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nValue(data=-8.0)\n```\n:::\n:::\n\n\n::: {#b9d45f39 .cell execution_count=38}\n``` {.python .cell-code}\nwiggle(1.0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nValue(data=-12.0)\n```\n:::\n:::\n\n\n### Propagating Back\n\nNow we want to calculate\n\n$$\\frac{\\partial{L}}{\\partial{c}}$$\n\nor put another way, we want to know how much $L$ wiggles if we wiggle $c$, or how $c$ influences $L$.\n\nLooking at the graph again we see that $c$ influences $e$ and $e$ influences $L$, so we should be able see the ripple effect of $c$ on $L$.\n\n$$ c \\rightarrow e \\rightarrow L $$\n\nSo $e = c + d$, and so we calculate\n\n$$ \\frac{\\partial{e}}{\\partial{c}} = \\frac{\\partial{}}{\\partial{c}} (d + c) = 1$$\n\n### Question\n\n$$ c \\rightarrow e \\rightarrow L $$\n\nSo now we know $\\partial{L}/\\partial{e}$ and we also know $\\partial{e}/\\partial{c}$,\n\nHow do we get $\\partial{L}/\\partial{c}$?\n\n### The Chain Rule\n\nTo paraphrase from the Wikipedia page on [Chain rule](https://en.wikipedia.org/wiki/Chain_rule), if a variable $L$ depends on the variable $e$, which itself depends on the variable $c$ (that is, $e$ and $L$ are dependent variables), then $L$ depends on $c$ as well, via the intermediate variable $e$. In this case, the chain rule is expressed as\n\n$$\\frac{\\partial L}{\\partial c} = \\frac{\\partial L}{\\partial e} \\cdot \\frac{\\partial e}{\\partial c},$$\n\nand\n\n$$ \\left.\\frac{\\partial L}{\\partial c}\\right|_{c} = \\left.\\frac{\\partial L}{\\partial e}\\right|_{e(c)}\\cdot \\left. \\frac{\\partial e}{\\partial c}\\right|_{c} ,$$\n\nfor indicating at which points the derivatives have to be evaluated.\n\nNow since we've established that\n\n$$ \\frac{\\partial{e}}{\\partial{c}} = 1$$\n\nthen\n\n$$\\frac{dL}{dc} = \\frac{dL}{de} \\cdot 1.$$\n\nSo in the case of an operand in an addition operation, we just copy the gradient of the parent node.\n\nOr put another way, \n\n> in the addition operator, we just route the parent gradient to the child.\n\n::: {#2c585c70 .cell tags='[]' execution_count=39}\n``` {.python .cell-code}\nd.grad = e.grad\nc.grad = e.grad\n```\n:::\n\n\n::: {#ae95a71f .cell slideshow='{\"slide_type\":\"subslide\"}' execution_count=40}\n``` {.python .cell-code}\ndraw_dot(L)\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n![](24-NN-II-Backprop_files/figure-html/cell-41-output-1.svg){}\n:::\n:::\n\n\nHow does $c$ and $d$ influence $L$?\n\n::: {#ca478ed8 .cell execution_count=41}\n``` {.python .cell-code}\n# Try uncommenting `c += h` or `d += h` and calling `wiggle()` then `wiggle(1.0)`\n# to see the influence of c or d on L\ndef wiggle(h = 0.0):\n    a = Value(4.0, label='a')\n    b = Value(-3.0, label='b')\n    c = Value(8.0, label='c')\n    # c += h\n\n    d = a*b; d.label = 'd'\n    # d += h\n\n    e = d + c; e.label = 'e'\n    f = Value(2.0, label='f')\n\n    L = e*f; L.label = 'L'\n    print(L)\n```\n:::\n\n\n::: {#115caee5 .cell execution_count=42}\n``` {.python .cell-code}\nwiggle()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nValue(data=-8.0)\n```\n:::\n:::\n\n\n::: {#d47ef2b3 .cell execution_count=43}\n``` {.python .cell-code}\nwiggle(1.0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nValue(data=-8.0)\n```\n:::\n:::\n\n\n### Propagating Back Again\n\nNow we want to calculate\n\n$$ \\frac{\\partial{L}}{\\partial{b}} \\hspace{10pt} \\textrm{and} \\hspace{10pt} \\frac{\\partial{L}}{\\partial{a}}$$\n\nBut we have\n\n$$ \\frac{\\partial{L}}{\\partial{d}}$$\n\nand we know that\n\n$$ \\frac{\\partial{d}}{\\partial{b}} = \\frac{\\partial{}}{\\partial{b}}(a\\cdot b) = a$$\n\nso again from the chain rule\n\n$$\\frac{\\partial{L}}{\\partial{b}} \n  = \\frac{\\partial{L}}{\\partial{d}} \\cdot \\frac{\\partial{d}}{\\partial{b}}\n  = \\frac{\\partial{L}}{\\partial{d}} \\cdot a$$\n\n::: {#70183aae .cell tags='[]' execution_count=44}\n``` {.python .cell-code}\nb.grad = a.data * d.grad\na.grad = b.data * d.grad\ndraw_dot(L)\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n![](24-NN-II-Backprop_files/figure-html/cell-45-output-1.svg){}\n:::\n:::\n\n\n::: {#97f9b5be .cell execution_count=45}\n``` {.python .cell-code}\n# Try uncommenting `a += h` or `b += h` and calling `wiggle()` then `wiggle(1.0)`\n# to see the influence of a or b on L\ndef wiggle(h = 0.0):\n    a = Value(4.0, label='a')\n    # a += h\n    b = Value(-3.0, label='b')\n    b += h\n    c = Value(8.0, label='c')\n\n    d = a*b; d.label = 'd'\n\n    e = d + c; e.label = 'e'\n    f = Value(2.0, label='f')\n\n    L = e*f; L.label = 'L'\n    print(L)\n```\n:::\n\n\n::: {#279b8340 .cell execution_count=46}\n``` {.python .cell-code}\nwiggle()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nValue(data=-8.0)\n```\n:::\n:::\n\n\n::: {#0554e531 .cell execution_count=47}\n``` {.python .cell-code}\nwiggle(1.0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nValue(data=0.0)\n```\n:::\n:::\n\n\n### Recap\n\nAs you saw, we recursively went backwards through the computation graph and applied the local gradients to the gradients calculated so far to get the partial gradients. Put another we propagated this calculations backwards through the graph.\n\nOf course, in practice, we will only need the gradients on the parameters, not the inputs, so we won't bother calculating them on inputs.\n\n_That is the essence of Back Propagation._\n\n## A Step in Optimization\n\nLet's take a look at the graph again. Assume we want the value of L to _decrease_. We are free to change the values of the leaf nodes -- all the other nodes are derived from children and leaf nodes.\n\nThe leaf nodes are $a, b, c$ and $f$.\n\n> Again, in practice we would only update the parameter leaf nodes, not the input leaf node, but we'll ignore that distinction temporarily for this exmaple.\n\n::: {#1cf780dc .cell tags='[]' execution_count=48}\n``` {.python .cell-code}\ndraw_dot(L)\n```\n\n::: {.cell-output .cell-output-display execution_count=48}\n![](24-NN-II-Backprop_files/figure-html/cell-49-output-1.svg){}\n:::\n:::\n\n\nLet's check the current value of L.\n\n::: {#091c34d9 .cell tags='[]' execution_count=49}\n``` {.python .cell-code}\n# remind ourselves what L is\nprint(L.data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-8.0\n```\n:::\n:::\n\n\nAs we showed before, we want to nudge each of those leaf nodes by the negative\nof the gradient, multiplied by a step size, $\\eta$.\n\n$$ w_{n+1} = w_n - \\eta * \\frac{\\partial{L}}{\\partial{w_n}} $$\n\nwhere $n$ is the iteration number.\n\n::: {#48582de6 .cell tags='[]' execution_count=50}\n``` {.python .cell-code}\n# nudge all the leaf nodes along the negative direction of the gradient\nstep_size = 0.01    # also called eta above\n\na.data -= step_size * a.grad\nb.data -= step_size * b.grad\nc.data -= step_size * c.grad\nf.data -= step_size * f.grad\n\n# recompute the forward pass\nd = a*b\ne = d + c\nL = e*f\n\nprint(L.data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-9.230591999999998\n```\n:::\n:::\n\n\n## A Single Neuron\n\nLet's now programmatically define a single neuron with\n* two inputs\n* two weights (1 for each input)\n* a bias\n* the ReLU activation function\n\nRecall the neuron figure above.\n\n::: {#33c4c3e9 .cell slideshow='{\"slide_type\":\"subslide\"}' tags='[]' execution_count=51}\n``` {.python .cell-code}\n# inputs x0, x1\nx1 = Value(2.0, label='x1')\nx2 = Value(0.0, label='x2')\n\n# weights w1, w2\nw1 = Value(-3.0, label='w1')\nw2 = Value(1.0, label='w2')\n\n# bias of the neuron\nb = Value(6.8813735870195432, label='b')\n\nx1w1 = x1*w1; x1w1.label = 'x1*w1'\nx2w2 = x2*w2; x2w2.label = 'x2*w2'\n\nx1w1x2w2 = x1w1 + x2w2; x1w1x2w2.label = 'x1w1 + x2w2'\nn = x1w1x2w2 + b; n.label = 'n'\no = n.relu(); o.label = 'o'\n```\n:::\n\n\n::: {#d9eca0c4 .cell tags='[]' execution_count=52}\n``` {.python .cell-code}\ndraw_dot(o)\n```\n\n::: {.cell-output .cell-output-display execution_count=52}\n![](24-NN-II-Backprop_files/figure-html/cell-53-output-1.svg){}\n:::\n:::\n\n\nThe only new operation we've added is the ReLU, so let's take a quick look at how we \ndifferentiate the ReLU. \n\nLike before, for the output node, o:\n\n$$ \\frac{\\partial o}{\\partial o} = 1 $$\n\n::: {#5078c2a2 .cell tags='[]' execution_count=53}\n``` {.python .cell-code}\no.grad = 1.0\n```\n:::\n\n\n<!-- Credit: _Understanding Deep Learning_, Figure 7.6 -->\nReLU is technically not differentiable at 0, but practically we implement the\nderivative as 0 when $ \\le 0$ and 1 when $ 1 > 0 $\n\n<center>\n\n<img src=\"figs/NN-figs/Train2ReLUDeriv.svg\" width=\"50%\">\n\n</center>\n\n::: {#c1f5c0d9 .cell tags='[]' execution_count=54}\n``` {.python .cell-code}\nn.grad = (o.data > 0) * o.grad  # = 0 when o.data <= 0; = o.grad when o.data > 0\n```\n:::\n\n\n## Coding Backpropagation\n\nNow we'll update our `Value` class once more to support the backward pass.\n\nThere's a\n* private `_backward()` function _in each operator_ that implements the local\nstep of the chain rule, and\n* a `backward()` function in the class that topologically sorts the graph and calls the operator `_backward()` function starting at the end of the graph and going _backward_.\n\n::: {#863bb939 .cell tags='[]' execution_count=55}\n``` {.python .cell-code}\n# version 9\nclass Value:\n\n    def __init__(self, data, _children=(), _op='', label=''):\n        self.data = data\n        self.grad = 0.0 # default to 0, no impact on the output\n        self._backward = lambda: None  # by default backward doesn't do anything\n        self._prev = set(_children)\n        self._op = _op\n        self.label = label\n\n    def __repr__(self):\n        \"\"\"Return a string representation of the object for display\"\"\"\n        return f\"Value(data={self.data}, grad={self.grad})\"\n\n    def __add__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data + other.data, (self, other), '+')\n\n        def _backward():\n            self.grad += out.grad\n            other.grad += out.grad\n        out._backward = _backward\n\n        return out\n\n    def __mul__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data * other.data, (self, other), '*')\n\n        def _backward():\n            self.grad += other.data * out.grad\n            other.grad += self.data * out.grad\n        out._backward = _backward\n        return out\n\n    def relu(self):\n        out = Value(np.maximum(0, self.data), (self,), 'ReLU')\n        # out = Value(0 if self.data < 0 else self.data, (self,), 'ReLU')\n\n        def _backward():\n            self.grad += (out.data > 0) * out.grad\n        out._backward = _backward\n\n        return out\n\n    def backward(self):\n\n        # topological order all of the children in the graph\n        topo = []\n        visited = set()\n        def build_topo(v):\n            if v not in visited:\n                visited.add(v)\n                for child in v._prev:\n                    build_topo(child)\n                topo.append(v)\n        build_topo(self)\n\n        # go one variable at a time and apply the chain rule to get its gradient\n        self.grad = 1\n        for v in reversed(topo):\n            v._backward()\n```\n:::\n\n\nWe redefined the class so we have to reinitialize the objects and run the operations again.\n\nThis constitutes the _forward pass_.\n\n::: {#fcc0034a .cell tags='[]' execution_count=56}\n``` {.python .cell-code}\n# inputs x0, x1\nx1 = Value(2.0, label='x1')\nx2 = Value(0.0, label='x2')\n\n# weights w1, w2\nw1 = Value(-3.0, label='w1')\nw2 = Value(1.0, label='w2')\n\n# bias of the neuron\n#b = Value(6.7, label='b')\nb = Value(6.8813735870195432, label='b')\n\nx1w1 = x1*w1; x1w1.label = 'x1*w1'\nx2w2 = x2*w2; x2w2.label = 'x2*w2'\n\nx1w1x2w2 = x1w1 + x2w2; x1w1x2w2.label = 'x1w1 + x2w2'\nn = x1w1x2w2 + b; n.label = 'n'\no = n.relu(); o.label = 'o'\n```\n:::\n\n\nSo we've filled the data values for all the nodes, but haven't calculated the gradients.\n\n::: {#d3a81a09 .cell tags='[]' execution_count=57}\n``` {.python .cell-code}\ndraw_dot(o)\n```\n\n::: {.cell-output .cell-output-display execution_count=57}\n![](24-NN-II-Backprop_files/figure-html/cell-58-output-1.svg){}\n:::\n:::\n\n\nNow, all we have to do is call the `backward()` method of the last node...\n\n::: {#080082c5 .cell execution_count=58}\n``` {.python .cell-code}\no.backward()\n```\n:::\n\n\nAnd voila! We have all the gradients!\n\n::: {#7ffa47b4 .cell execution_count=59}\n``` {.python .cell-code}\ndraw_dot(o)\n```\n\n::: {.cell-output .cell-output-display execution_count=59}\n![](24-NN-II-Backprop_files/figure-html/cell-60-output-1.svg){}\n:::\n:::\n\n\n### Accumulating the Gradients\n\nThe observant viewer will notice that we are accumulating the gradients.\n\nThat is to handle cases like where a `Value` object is on both sides of the operand like\n\n::: {#d532dbe0 .cell tags='[]' execution_count=60}\n``` {.python .cell-code}\na = Value(3.0, label='a')\nb = a + a ; b.label = 'b'\nb.backward()\n\na\n```\n\n::: {.cell-output .cell-output-display execution_count=60}\n```\nValue(data=3.0, grad=2.0)\n```\n:::\n:::\n\n\nIf we didn't have the accumulation, then `a.grad = 1` instead.\n\nOr the other case where a node goes to different operations.\n\n::: {#aa68e38f .cell tags='[]' execution_count=61}\n``` {.python .cell-code}\na = Value(-2.0, label='a')\nb = Value(3.0, label='b')\nd = a * b  ; d.label = 'd'\ne = a + b   ; e.label = 'e'\n  \ndraw_dot( f) \n```\n\n::: {.cell-output .cell-output-display execution_count=61}\n![](24-NN-II-Backprop_files/figure-html/cell-62-output-1.svg){}\n:::\n:::\n\n\nYou can see analytical verification of the above result in the note in the online book.\n\nThe risk now is that if you don't zero the gradients for the next update iteration, you will have incorrect gradients. \n\n> Always remember to zero the gradient in each iteration of the training loop!\n\n\n\n\n```{note}\n\nWe can verify that the gradients are correct analytically.\n\nTo find the partial derivative $\\frac{\\partial f}{\\partial a}$, we first need to define $f$ in terms of $a$ and $b$.\n\nGiven:\n$$\\begin{aligned}\nd &= a \\times b \\\\\ne &= a + b      \\\\\nf &= d \\times e\n\\end{aligned}$$\n\nThen $f$ can be expanded as:\n$$\\begin{aligned}\nf &= (a \\times b) \\times (a + b) \\\\\nf &= a^2 \\times b + a \\times b^2\n\\end{aligned}$$\n\nNext, we find the partial derivative of $f$ with respect to $a$:\n$$ \\frac{\\partial f}{\\partial a} = 2a \\times b + b^2 $$\n\nFinally, we plug in the given values $a = -2.0$ and $b = 3.0$:\n$$\\begin{aligned}\n\\frac{\\partial f}{\\partial a} &= 2(-2.0) \\times 3.0 + 3.0^2 \\\\\n\\frac{\\partial f}{\\partial a} &= -12.0 + 9.0                 \\\\\n\\frac{\\partial f}{\\partial a} &= -3.0\n\\end{aligned}$$\n\nSo the partial derivative $\\frac{\\partial f}{\\partial a}$ for the value $a = -2.0$ is $-3.0$.\n\n```\n\n\n\n\n## Enhancements to `Value` Class\n\nThere are still some useful operations that `Value` doesn't support, so to be more\ncomplete we have the final version of the `Value` class below.\n\nWe added:\n* `__radd__` for when the `Value` object is the right operand of an add\n* `__rmul__` for when the `Value` object is the right operand of a product \n* `__pow__` to support the ** operator\n* plus some others you can see below\n\n::: {#98893b21 .cell execution_count=62}\n``` {.python .cell-code}\n# version 9\nclass Value:\n\n    def __init__(self, data, _children=(), _op='', label=''):\n        self.data = data\n        self.grad = 0.0 # default to 0, no impact on the output\n        self._backward = lambda: None  # by default backward doesn't do anything\n        self._prev = set(_children)\n        self._op = _op\n        self.label = label\n\n    def __add__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data + other.data, (self, other), '+')\n\n        def _backward():\n            self.grad += out.grad\n            other.grad += out.grad\n        out._backward = _backward\n\n        return out\n    \n    def __mul__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data * other.data, (self, other), '*')\n\n        def _backward():\n            self.grad += other.data * out.grad\n            other.grad += self.data * out.grad\n        out._backward = _backward\n        \n        return out\n\n    def __pow__(self, other):\n        \"\"\"Adding support for ** operator, which we'll need for the \n        squared loss function\"\"\"\n        assert isinstance(other, (int, float)), \"only supporting int/float powers for now\"\n        out = Value(self.data**other, (self,), f'**{other}')\n\n        def _backward():\n            self.grad += (other * self.data**(other-1)) * out.grad\n        out._backward = _backward\n\n        return out\n\n    def relu(self):\n        out = Value(np.maximum(0, self.data), (self,), 'ReLU')\n        # out = Value(0 if self.data < 0 else self.data, (self,), 'ReLU')\n\n        def _backward():\n            self.grad += (out.data > 0) * out.grad\n        out._backward = _backward\n\n        return out\n\n    def __neg__(self): # -self\n        return self * -1\n\n    def __radd__(self, other): # other + self\n        return self + other\n\n    def __sub__(self, other): # self - other\n        return self + (-other)\n\n    def __rsub__(self, other): # other - self\n        return other + (-self)\n\n    def __rmul__(self, other): # other * self\n        return self * other\n\n    def __truediv__(self, other): # self / other\n        return self * other**-1\n\n    def __rtruediv__(self, other): # other / self\n        return other * self**-1\n    \n    def backward(self):\n\n        # topological order all of the children in the graph\n        topo = []\n        visited = set()\n        def build_topo(v):\n            if v not in visited:\n                visited.add(v)\n                for child in v._prev:\n                    build_topo(child)\n                topo.append(v)\n        build_topo(self)\n\n        # go one variable at a time and apply the chain rule to get its gradient\n        self.grad = 1\n        for v in reversed(topo):\n            v._backward()\n\n    def __repr__(self):\n        \"\"\"Return a string representation of the object for display\"\"\"\n        return f\"Value(data={self.data}, grad={self.grad})\"\n```\n:::\n\n\n## Comparing to PyTorch\n\nWe're using a class implementation that resembles the PyTorch implementation, and in fact we can compare our implementation with PyTorch.\n\n::: {#f87c9fa0 .cell tags='[]' execution_count=63}\n``` {.python .cell-code}\nimport torch\n```\n:::\n\n\n::: {#1a6daaab .cell tags='[]' execution_count=64}\n``` {.python .cell-code}\nx1 = torch.Tensor([2.0]).double()                ; x1.requires_grad = True\nx2 = torch.Tensor([0.0]).double()                ; x2.requires_grad = True\nw1 = torch.Tensor([-3.0]).double()               ; w1.requires_grad = True\nw2 = torch.Tensor([1.0]).double()                ; w2.requires_grad = True\nb = torch.Tensor([6.8813735870195432]).double()  ; b.requires_grad = True\nn = x1*w1 + x2*w2 + b\no = torch.relu(n)\n\nprint(o.data.item())\no.backward()\n\nprint('---')\nprint('x2.grad', x2.grad.item())\nprint('w2.grad', w2.grad.item())\nprint('x1.grad', x1.grad.item())\nprint('w1.grad', w1.grad.item())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.881373405456543\n---\nx2.grad 1.0\nw2.grad 0.0\nx1.grad -3.0\nw1.grad 2.0\n```\n:::\n:::\n\n\nBy default, tensors don't store gradients and so won't support backprop, so we explicitly set `requires_grad = True`.\n\n## Neural Network Modules\n\nNow we'll define some classes which help us build out a small neural network.\n\n__Module__ -- A base class\n\n__Neuron__ -- Implement a single linear or nonlinear neuron with `nin` inputs.\n\n__Layer__ -- Implement a layer of network consisting of `nout` neurons, each taking `nin` inputs\n\n__MLP__ -- A _Multi-Layer Perceptron_ that implements `len(nouts)` layers of neurons.\n\nEach class can calculate a forward pass and enumerate all its parameters.\n\n::: {#3416d2f8 .cell slideshow='{\"slide_type\":\"subslide\"}' tags='[]' execution_count=65}\n``` {.python .cell-code}\nimport random\n# we assume that Value class is already defined\n\nclass Module:\n    \"\"\"Define a Neural Network Module base class \"\"\"\n\n    def zero_grad(self):\n        \"\"\"When we run in a training loop, we'll need to zero out all the gradients\n        since they are defined to accumulate in the backwards passes.\"\"\"\n        for p in self.parameters():\n            p.grad = 0\n\n    def parameters(self):\n        return []\n\nclass Neuron(Module):\n    \"\"\"Define a Neuron as a subclass of Module\"\"\"\n\n    def __init__(self, nin, nonlin=True):\n        \"\"\"Randomly initialize a set of weights, one for each input, and initialize the bias to zero.\"\"\"\n        self.w = [Value(random.uniform(-1,1)) for _ in range(nin)]\n        self.b = Value(0.0)\n        self.nonlin = nonlin\n\n    def __call__(self, x):\n        \"\"\"Implement the forward pass of the neuron\"\"\"\n        act = sum((wi*xi for wi,xi in zip(self.w, x)), self.b)\n        return act.relu() if self.nonlin else act\n\n    def parameters(self):\n        return self.w + [self.b]\n\n    def __repr__(self):\n        return f\"{'ReLU' if self.nonlin else 'Linear'}Neuron({len(self.w)})\"\n\nclass Layer(Module):\n    \"\"\"Define a Layer of Network as a subclass of Module\"\"\"\n\n    def __init__(self, nin, nout, **kwargs):\n        \"\"\"Initialize nout Neurons, each with nin inputs\"\"\"\n        self.neurons = [Neuron(nin, **kwargs) for _ in range(nout)]\n\n    def __call__(self, x):\n        \"\"\"Forward pass each neuron in the layer\"\"\"\n        out = [n(x) for n in self.neurons]\n        return out[0] if len(out) == 1 else out\n\n    def parameters(self):\n        return [p for n in self.neurons for p in n.parameters()]\n\n    def __repr__(self):\n        return f\"Layer of [{', '.join(str(n) for n in self.neurons)}]\"\n\nclass MLP(Module):\n    \"\"\"Define a Multi-Layer Perceptron\"\"\"\n\n    def __init__(self, nin: int, nouts: list):\n        \"\"\"\n        Initialize the Multi-Layer Perceptron, by initializing each layer\n        then initializing each neuron of each layer.\n\n        Parameters:\n            nin: Number of inputs (int)\n            nouts: A list of the number of neurons in each layer\n        \"\"\"\n        sz = [nin] + nouts\n        # self.layers = [Layer(sz[i], sz[i+1]) for i in range(len(nouts))]\n\n        # Create a list of layer objects for this MLP. All but the last layer\n        # have ReLU activations. The last layer is linear.\n        self.layers = [Layer(sz[i], sz[i+1], nonlin=i!=len(nouts)-1) for i in range(len(nouts))]\n\n    def __call__(self, x):\n        \"\"\"Forward pass through the MLP\"\"\"\n        for layer in self.layers:\n            x = layer(x)\n        return x\n\n    def parameters(self):\n        \"\"\"Recursively retrieve the parameters of the MLP\"\"\"\n        return [p for layer in self.layers for p in layer.parameters()]\n\n    def __repr__(self):\n        return f\"MLP of [{', '.join(str(layer) for layer in self.layers)}]\"\n```\n:::\n\n\n::: {#cef0d379 .cell tags='[]' execution_count=66}\n``` {.python .cell-code}\n# help(Module)\n# Module.__doc__\n# help(Neuron)\n# help(Layer)\n# help(MLP)\n```\n:::\n\n\n### Initialize and Evaluate a Neuron\n\n::: {#9b2de4fb .cell tags='[]' execution_count=67}\n``` {.python .cell-code}\n# 2 inputs\nx = [2.0, 3.0]\n\n# initialize neuron with 2 inputs\nn = Neuron(2, nonlin=False)\n\n# evaluate our neuron with our 2 inputs\nn(x)\n```\n\n::: {.cell-output .cell-output-display execution_count=67}\n```\nValue(data=2.484351760665339, grad=0.0)\n```\n:::\n:::\n\n\n::: {#c6081da0 .cell execution_count=68}\n``` {.python .cell-code}\nn\n```\n\n::: {.cell-output .cell-output-display execution_count=68}\n```\nLinearNeuron(2)\n```\n:::\n:::\n\n\n::: {#edefec3b .cell tags='[]' execution_count=69}\n``` {.python .cell-code}\n# list the 2 weights and the bias\nn.parameters()\n```\n\n::: {.cell-output .cell-output-display execution_count=69}\n```\n[Value(data=0.9300279641945854, grad=0.0),\n Value(data=0.2080986107587226, grad=0.0),\n Value(data=0.0, grad=0.0)]\n```\n:::\n:::\n\n\n### Initialize and Evaluate a Layer of Neurons\n\n::: {#b333f1f8 .cell tags='[]' execution_count=70}\n``` {.python .cell-code}\n# same 2 inputs again\nx = [2.0, 3.0]\n\n# Now initialize a layer of 3 neurons, each with 2 inputs\nl = Layer(2, 3, nonlin=False)\n\n# Evaluate our layer of neurons with the 2 inputs\nl(x)\n```\n\n::: {.cell-output .cell-output-display execution_count=70}\n```\n[Value(data=-1.944215892129021, grad=0.0),\n Value(data=1.2040280353187238, grad=0.0),\n Value(data=-2.58171034572677, grad=0.0)]\n```\n:::\n:::\n\n\n::: {#b7db0af5 .cell execution_count=71}\n``` {.python .cell-code}\nl\n```\n\n::: {.cell-output .cell-output-display execution_count=71}\n```\nLayer of [LinearNeuron(2), LinearNeuron(2), LinearNeuron(2)]\n```\n:::\n:::\n\n\n::: {#f12e733b .cell tags='[]' execution_count=72}\n``` {.python .cell-code}\nl.parameters()\n```\n\n::: {.cell-output .cell-output-display execution_count=72}\n```\n[Value(data=-0.16314940032645775, grad=0.0),\n Value(data=-0.5393056971587018, grad=0.0),\n Value(data=0.0, grad=0.0),\n Value(data=-0.39282735800966306, grad=0.0),\n Value(data=0.66322758377935, grad=0.0),\n Value(data=0.0, grad=0.0),\n Value(data=0.1609331325418457, grad=0.0),\n Value(data=-0.9678588702701538, grad=0.0),\n Value(data=0.0, grad=0.0)]\n```\n:::\n:::\n\n\n### Initialize and Evaluate an MLP\n\nWe'll instantiate an MLP like the picture below.\n\n<center>\n<img src=\"figs/NN-figs/neural_net2.jpeg\" width=\"75%\">\n</center>\n\n\nFrom [cs231n](https://cs231n.github.io/convolutional-networks/)\n\n::: {#9c2ade56 .cell tags='[]' execution_count=73}\n``` {.python .cell-code}\nx = [2.0, 3.0, -1.0]\nm = MLP(3, [4, 4, 1])\nm(x)\n```\n\n::: {.cell-output .cell-output-display execution_count=73}\n```\nValue(data=-0.8541015192442617, grad=0.0)\n```\n:::\n:::\n\n\n::: {#4ff217d5 .cell execution_count=74}\n``` {.python .cell-code}\nm\n```\n\n::: {.cell-output .cell-output-display execution_count=74}\n```\nMLP of [Layer of [ReLUNeuron(3), ReLUNeuron(3), ReLUNeuron(3), ReLUNeuron(3)], Layer of [ReLUNeuron(4), ReLUNeuron(4), ReLUNeuron(4), ReLUNeuron(4)], Layer of [LinearNeuron(4)]]\n```\n:::\n:::\n\n\n::: {#5622a2a8 .cell execution_count=75}\n``` {.python .cell-code}\n# m.parameters()\n```\n:::\n\n\n::: {#00106a1f .cell slideshow='{\"slide_type\":\"subslide\"}' tags='[]' execution_count=76}\n``` {.python .cell-code}\ndraw_dot(m(x))\n```\n\n::: {.cell-output .cell-output-display execution_count=76}\n![](24-NN-II-Backprop_files/figure-html/cell-77-output-1.svg){}\n:::\n:::\n\n\n## Training Loop\nSo after manually iterating, we put it all together in a training loop. We can repeatedly execute the next cell to continue training. \n\n::: {#470749bc .cell execution_count=77}\n``` {.python .cell-code}\n# Define 4 different sets of inputs\nxs = [\n    [2.0, 3.0, -1.0],\n    [3.0, -1.0, 0.5],\n    [0.5, 1.0, 1.0],\n    [1.0, 1.0, -1.0]\n]\n\n# For each input set, we have a desired target value -- binary classification\n# ys = [1.0, -1.0, -1.0, 1.0]\nys = [1.0, 0.0, 0.0, 1.0]\n\n# Manually seed the Random Number Generator for Reproducibility\n# You can comment the next line out see the variability\nnp.random.seed(1)\n\n# Initialize an MLP with random weights\nm = MLP(3, [4, 4, 1])\n```\n:::\n\n\n::: {#bad1dec3 .cell slideshow='{\"slide_type\":\"subslide\"}' tags='[]' execution_count=78}\n``` {.python .cell-code}\nlosses = []\nniters = 100\nstep_size = 0.01\n\nfor k in range(niters):\n\n    # Training Step 1: forward pass\n    ypred = [m(x) for x in xs]\n    \n    # Training Step 2: Calculate the loss\n    loss = sum((yout - ygt)**2 for ygt, yout in zip(ys, ypred))\n    losses.append(loss.data)\n\n    # Training Step 3: Zero the gradients and run the backward pass\n    m.zero_grad()\n    loss.backward()\n\n    # Training Step 4: Update parameters\n    for p in m.parameters():\n        p.data += -step_size * p.grad\n\n    # print(k, loss.data)\n\nprint(\"Final Loss: \", loss.data)\n    \nplt.plot(losses)\nplt.ylabel(\"Loss\")\nplt.xlabel(\"Iterations\")\nplt.title(\"Loss Per Iteration\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFinal Loss:  0.0032577415734693625\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=78}\n```\nText(0.5, 1.0, 'Loss Per Iteration')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](24-NN-II-Backprop_files/figure-html/cell-79-output-3.png){width=589 height=449}\n:::\n:::\n\n\n::: {#07b110f8 .cell tags='[]' execution_count=79}\n``` {.python .cell-code}\nypred\n```\n\n::: {.cell-output .cell-output-display execution_count=79}\n```\n[Value(data=1.0247480573031107, grad=0.049496114606221386),\n Value(data=0.008570385259044855, grad=0.01714077051808971),\n Value(data=0.0029016542903415876, grad=0.005803308580683175),\n Value(data=0.9493699285791319, grad=-0.10126014284173612)]\n```\n:::\n:::\n\n\n## Build and Train the Equivalent MLP in PyTorch\n\n::: {#fc4c0a8b .cell execution_count=80}\n``` {.python .cell-code}\nimport torch\nfrom torch import nn\nfrom torch.optim import SGD\n\n# Manually seed the Random Number Generator for Reproducibility\n# You can comment the next line out see the variability\ntorch.manual_seed(99)\n\n# Step 1: Define the MLP model\nclass ptMLP(nn.Module):\n    def __init__(self):\n        super(ptMLP, self).__init__()\n        self.layers = nn.Sequential(\n            nn.Linear(3, 4),\n            nn.ReLU(),\n            nn.Linear(4, 4),\n            nn.ReLU(),\n            nn.Linear(4, 1)\n        )\n\n    def forward(self, x):\n        return self.layers(x)\n\nmodel = ptMLP()\nprint(model)\n\n# Step 2: Define a loss function and an optimizer\ncriterion = nn.MSELoss(reduction='sum')\noptimizer = SGD(model.parameters(), lr=0.01)\n\n# Step 3: Create a tiny dataset\nxs = [\n    [2.0, 3.0, -1.0],\n    [3.0, -1.0, 0.5],\n    [0.5, 1.0, 1.0],\n    [1.0, 1.0, -1.0]\n]\n\n# we had to transpose ys for torch.tensor\nys_transpose = [[1.0], \n      [0.0], \n      [0.0], \n      [1.0]]\n\ninputs = torch.tensor(xs)\noutputs = torch.tensor(ys_transpose)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nptMLP(\n  (layers): Sequential(\n    (0): Linear(in_features=3, out_features=4, bias=True)\n    (1): ReLU()\n    (2): Linear(in_features=4, out_features=4, bias=True)\n    (3): ReLU()\n    (4): Linear(in_features=4, out_features=1, bias=True)\n  )\n)\n```\n:::\n:::\n\n\nNow run the training loop.\n\n::: {#d0315758 .cell execution_count=81}\n``` {.python .cell-code}\n# Step 4: Write the training loop\nlosses = []\nniters = 100\n\nfor epoch in range(niters):\n\n    # Training Step 1: Forward pass\n    predictions = model(inputs)\n\n    # Training Step 2: Calculate the loss\n    loss = criterion(predictions, outputs)\n\n    # Training Step 3: Zero the gradient and run backward pass\n    optimizer.zero_grad()\n    loss.backward()\n\n    # Training Step 4: Update parameters\n    optimizer.step()\n\n    losses.append(loss.item())\n    # print(f'Epoch {epoch+1}, Loss: {loss.item()}')\n\nprint(f'Final Loss: {loss.item()}')\n\nplt.plot(losses)\nplt.ylabel(\"Loss\")\nplt.xlabel(\"Iterations\")\nplt.title(\"Loss Per Iteration\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFinal Loss: 0.06534025073051453\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=81}\n```\nText(0.5, 1.0, 'Loss Per Iteration')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](24-NN-II-Backprop_files/figure-html/cell-82-output-3.png){width=589 height=449}\n:::\n:::\n\n\n::: {#a69cfd15 .cell execution_count=82}\n``` {.python .cell-code}\npredictions\n```\n\n::: {.cell-output .cell-output-display execution_count=82}\n```\ntensor([[1.1306],\n        [0.0364],\n        [0.0176],\n        [0.7840]], grad_fn=<AddmmBackward0>)\n```\n:::\n:::\n\n\n## To Dig a Little Deeper\n\n[PyTorch Quick Start Tutorial](https://pytorch.org/tutorials/beginner/basics/intro.html)\n\n[TensorFlow Playground](https://playground.tensorflow.org/#activation=relu&batchSize=30&dataset=gauss&regDataset=reg-plane&learningRate=0.01&regularizationRate=0&noise=0&networkShape=4,4&seed=0.75152&showTestData=false&discretize=false&percTrainData=50&x=true&y=true&xTimesY=false&xSquared=false&ySquared=false&cosX=false&sinX=false&cosY=false&sinY=false&collectStats=false&problem=classification&initZero=false&hideText=false)\n\n## Summary\n\nSo today we...\n\n* got a glimpse of the wide applications of neural networks\n* revisited loss functions\n* developed the notion of gradient descent first by intuition, then in the univariate case, then the multivariate case\n* defined artificial neurons\n* implemented a computation graph and visualization\n* implemented the chain rule as backpropagation on the computation graph\n* defined Neuron, Layer and MLP modules which completes are homegrown Neural Network Framework\n* then trained a small MLP on a tiny dataset\n* finally implemented the same in PyTorch\n\n",
    "supporting": [
      "24-NN-II-Backprop_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}