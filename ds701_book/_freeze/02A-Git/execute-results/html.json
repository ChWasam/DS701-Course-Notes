{
  "hash": "0c478c6596997420df658997f78754c8",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'Essential Tools: Git'\n---\n\n::: {.content-hidden when-profile=\"slides\"}\nThis course focuses on developing practical skills in working with data and providing students with a hands-on understanding of classical data analysis techniques. \n\nThis will be a coding-intensive course. \n\nInstruction in this course uses [Python](https://www.python.org/), since it allows for fast prototyping and is supported by a great variety of scientific (and, specifically, data related) libraries. See the [Introduction to Python](01-Intro-to-Python.qmd) lecture for a Python refresher.\n\nThe course notes can be found under [this GitHub account](https://github.com/tools4ds/DS701-Course-Notes). Rendered versions of the course notes can be found [here](https://tools4ds.github.io/DS701-Course-Notes/). \n\nThe lecture notes of this course are rendered from [Quarto](https://quarto.org/) markdown files. The homeworks of this course are [Jupyter notebooks](https://jupyter.org).\n:::\n\n__Today's Agenda__ is a review of the essential tools you will need for this course.\n\nWe are __not__ providing a comprehensive introduction to these tools.\n\nThey are all __extensively__ documented online and you will need to familiarize with online resources to learn what you need.  \n\nStack overflow, etc, is also your friend -- but as a reference, not as a way to solve homework problems!\n\n__The key tools you will need__ are:\n\n::: {.incremental}\n1. Git\n1. Pandas\n1. Scikit-Learn \n:::\n\n## Git\n\nOne of the goals of this course is make you familiar with the modern workflow of code-versioning and collaboration. \n\nIf you don't have it already, download **git** from [here](http://git-scm.com/downloads). \n\nIf you don't already have one, you __must__ also create an account on GitHub.\n\nYou can find extensive documentation on how to use **git** on the [Git home page](https://git-scm.com/), the [Help Pages of Github](https://docs.github.com/en/get-started/quickstart), on [Atlassian](https://www.atlassian.com/git/tutorials/setting-up-a-repository), and many other sites.\n\n## Importance of using Git\n\nIn software development, the use of Git is crucial for several reasons.\n\n::: {.incremental}\n1. **Version Control**: Git allows you to track changes in your codebase over time. This means you can revert to previous versions if something goes wrong, compare changes, and understand the history of your project.\n1. **Collaboration**: Multiple developers can work on the same project simultaneously without interfering with each other’s work. Git manages and merges changes efficiently.\n1. **Backup**: Your code is stored in a repository, which can be hosted on platforms like GitHub, GitLab, or Bitbucket. This provides a backup in case your local files are lost or corrupted.\n1. **Branching**: Git’s branching model allows you to create separate branches for new features, bug fixes, or experiments. This keeps the main codebase stable and clean.\n1. **Integration**: Git integrates well with various CI/CD (continuous integration/continuous development) tools, enhancing automated testing, deployment, and overall DevOps practices.\n:::\n\n## Working with Git\n\nWe will now introduce the following topics:\n\n::: {.incremental}\n- Git configuration\n- Repository creation\n- Staging and committing files\n- Modifying files\n- Recovering old versions\n- Branching\n- Pull requests\n:::\n\n## Configuration\n\nThe first time we use *git* on a new machine, we need to configure our name and email\n\n```{sh}\n$ git config --global user.name \"Taylor Swift\"\n$ git config --global user.mail \"tswift@bu.edu\"\n```\n\nUse the email that you used for your GitHub account.\n\n## Creating a Repository\n\nAfter installing Git, we can configure our first repository. First, let's create a new directory.\n\n```{sh}\n$ mkdir thoughts\n$ cd thoughts\n```\n\nNow, we can create a *git* repository in this directory.\n\n```{sh}\n$ git init\n```\n\nWe can check that everything is set up correctly by asking *git* to tell us the status of our project.\n\n```{sh}\n$ git status\nOn branch main\n\nNo commits yet\n\nnothing to commit (create/copy files and use \"git add\" to track)\n```\n\n## Staging \n\nNow, create a file named ```science.txt```, edit it with your favorite text editor and add the following lines.\n\n```{sh}\nStarting to think about data\n```\n\nIf we check the status of our repository again, *git* tells us that there is a new file.\n\n```{sh}\n$ git status\nOn branch main\n\nNo commits yet\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n        science.txt\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n```\n\nTo give you precise control about what changes are included in each revision, *git* has a special staging area.\n\nIn the staging area it keeps track of things that you have added to the current change set but not yet committed. \n\n::: {.content-hidden when-profile=\"web\"}\n## Staging continued\n:::\n\n```git add``` puts things in this area.\n\nThe \"untracked files\" message means that there's a file in the directory that *git* isn't keeping track of. We can tell *git* that it should do so using ```git add```\n\n```{sh}\n$ git add science.txt\n```\n\nand then check that the file is now being tracked\n\n```{sh{}}\n$ git status\nOn branch main\n\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached <file>...\" to unstage)\n\n        new file:   science.txt\n\n```\n\n*git* now knows that it's supposed to keep track of ```science.txt```, but it hasn't yet recorded any changes. \n\n## Committing\n\nThe command ```git commit```  copies the staged changes to long-term storage (as a commit). The graphic below illustrates this process.\n\n![](./figs/git-staging-area.png)\n\nTo commit our file, we run the command.\n\n```{sh}\n$ git commit -m \"Added initial science text file\"\n[main (root-commit) f516d22] Added initial science text file\n 1 file changed, 1 insertion(+)\n create mode 100644 science.txt\n```\n\n::: {.content-hidden when-profile=\"web\"}\n## Committing continued\n:::\n\n::: {.fragment}\nWhen we run ```git commit```, *git* takes everything we have told it to save by using ```git add``` and stores a copy permanently inside the special ```.git``` directory. \n::: \n\n::: {.fragment}\nThis permanent copy is called a **revision** and its short identifier is *f516d22*. (Your revision will have another identifier.)\n:::\n\n::: {.fragment}\nWe use the -m flag (for \"message\") to record a comment that will help us remember later on what we did and why. \n:::\n\n::: {.content-hidden when-profile=\"web\"}\n## Committing continued\n:::\n\nIf we just run ```git commit``` without the ```-m``` option, *git* will launch an editor such as ```vim``` (or whatever other editor we configured at the start) so that we can write a longer message. \n\nIf we run git status now\n\n```{sh}\n$ git status\nOn branch main\nnothing to commit, working tree clean\n```\n\nit tells us everything is up to date. If we want to know what we've done recently, we can ask *git* to show us the project's history using ```git log```.\n\n```{sh}\n$ git log\nAuthor: Taylor Swift <tswift@bu.edu>\nDate:   Sun Jan 25 12:48:44 2015 -0500\n\n    Added initial science text file\n```\n\n## Commit messages\n\nWhen working on software engineering projects you will need to write good committ messages. Good commit messages are essential for maintaining a clear project history. A good commit message provides context for the changes in the code. The changes themselves can be seend in the committ. \n\nHere are some tips that are detailed further in this [blog post](https://cbea.ms/git-commit/). \n\n::: {.incremental}\n1. **Be Descriptive**: Clearly explain what changes were made and why. This helps others (and your future self) understand the purpose of the commit.\n1. **Use the Imperative Mood**: Start with a verb, like “Add,” “Fix,” “Update,” etc. For example, “Fix login bug” or “Add user authentication.”\n1. **Keep It Concise**: The first line should be a brief summary (50 characters or less). If more detail is needed, add a blank line followed by a more detailed explanation.\n1. **Reference Issues or Tickets**: If your commit addresses a specific issue or ticket, reference it in the message. For example, “Fix login bug (#123).”\n:::\n\n## Changing a file\n\nNow, suppose that we edit the file.\n\n```{sh}\nStarting to think about data\nI need to attend ds701\n```\n\nNow if we run ```git status```, *git* will tell us that a file that it is tracking has been modified:\n\n```{sh}\n$ git status\nOn branch main\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n        modified:   science.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\nThe last line is the key phrase: *\"no changes added to commit\"*. \n\nWe have changed this file, but we haven't told *git* we will want to save those changes (which we do with ```git add```) much less actually saved them. \n\n::: {.content-hidden when-profile=\"web\"}\n## Git diff\n:::\nLet's double-check our work using ```git diff```, which shows us the differences between the current state of the file and the most recently saved version.\n\n```{sh}\n$ git diff\ndiff --git a/science.txt b/science.txt\nindex 0ac4b7b..c5b1b05 100644\n--- a/science.txt\n+++ b/science.txt\n@@ -1 +1,2 @@\n Starting to think about data\n+I need to attend ds701\n```\n\nOK, we are happy with that, so let's commit our change.\n\n```{sh}\n$ git commit -m \"Added line about related course\"\nOn branch main\nChanges not staged for commit:\n        modified:   science.txt\n\nno changes added to commit\n```\n\n::: {.content-hidden when-profile=\"web\"}\n## Beware\n:::\n*Whoops!* *Git* won't commit the file because we didn't use ```git add``` first. Let's fix that.\n\n```{sh}\n$ git add science.txt\n$ git commit -m \"Added line about related course\"\n[main 1bd7277] Added line about related course\n 1 file changed, 1 insertion(+)\n```\n\n*Git* insists that we add files to the set we want to commit before actually committing anything because we may not want to commit everything at once. \n\nFor example, suppose we're adding a few citations to our project. We might want to commit those additions, and the corresponding addition to the bibliography, but not commit the work we're doing on the analysis (which we haven't finished yet).\n\n## Recovering old versions\n\nWe can save changes to files and see what we have changed. How can we restore older versions however? Let's suppose we\naccidentally overwrite the file but didn't stage the changes.\n\n```{sh}\n$ echo \"Despair! Nothing works\" > science.txt\n$ cat science.txt\nDespair! Nothing works\n```\n\nNow, `git status` tells us that the file has been changed, but those changes haven't been staged.\n\n```{sh}\n$ git status\nOn branch main\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n        modified:   science.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\nWe can put things back the way they were by using ```git checkout```.\n\n```{sh}\n$ git checkout -- science.txt\n$ cat science.txt\nStarting to think about data\nI need to attend ds701\n```\n\n## Recovering old versions, continued\n\nWhat if we changed it and checked it in?\n\n```{sh}\n$ echo \"Despair! Nothing works\" > science.txt\n$ cat science.txt\nDespair! Nothing works\n\n$ git add science.txt\n$ git commit -m \"Added exclamation\"\n```\n\nWe have a new commit, but we want to go back to the previous version.\n\nWe have two options:\n\n**Option 1: Undo the commit and unstage the changes**\n\n```{sh}\n$ git reset --soft HEAD~1\n```\n\nNow do `git status`.\n\n```{sh}\n$ git status\nOn branch main\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n        modified:   science.txt\n```\n\n**Option 2: Throw away the changes we have made and go back to the last commit**\n\nLet's commit the changes.\n\n```{sh}\n$ git commit -m \"oops again\"\n```\n\nBut now we want to throw away the commit.\n\n```{sh}\n$ git reset --hard HEAD~1\n\n$ cat science.txt\nStarting to think about data\nI need to attend ds549\n\n$ git status\nOn branch main\nnothing to commit, working tree clean\n```\n\n## GitHub\n\nSystems like *git* allow us to move work between any two repositories.\n\nIn practice, though, it's easiest to use one copy as a central hub (origin), and to keep it on the web rather than on someone's laptop. Most programmers use hosting services like [GitHub](https://github.com/) to hold those master copies. \n\nFor the purpose of our course, we will be using [GitHub](https://github.com/) to host the course material. \n\nYou will also submit your homeworks through this platform. \n\nNext, we will cover how you can clone the course's repository and how to submit your solutions to the homework. \n\n::: {.content-hidden when-profile=\"web\"}\n## Github continued\n:::\n\nFor more information on how to create your own repository on GitHub and upload code to it, please see \n[Start your journey -- Learn the basics of GitHub](https://docs.github.com/en/get-started/start-your-journey).\n\n![](figs/github-workflow.jpg)\n\n::: {.callout-note}\nTo be more accurate, the figure should indicate another lollipop which is the\nlocal copy of the remote repository.\n:::\n\n::: {.content-hidden when-profile=\"web\"}\n## Github continued\n:::\n\nThis workflow shows you the essential new commands:\n\n::: {.incremental}\n* ``git pull``\n* ``git push``\n:::\n\n::: {.fragment}\nAnd when you first copy a remote repository, you will use:\n\n* ``git clone``\n::: \n\n## Git pull\n\nThe git pull command is used in Git to update your local repository with changes from a remote repository. Essentially,\nit combines two other commands: ```git fetch``` and ```git merge```.\n\nHere’s a breakdown of what happens when you run git pull:\n\n1. **Fetch Changes**: It first fetches the changes from the remote repository, _updating your local copy_ of the remote branches.\n1. **Merge Changes**: It then merges these changes into your current local branch.\nThis means that git pull will bring your local branch up to date with the remote branch, incorporating any new commits that have been made.\n\n## Git push\n\nThe git push command is used to upload the content of your local repository to a remote repository. This is how you transfer commits from your local repository to a remote one, making your changes available to others.\n\nHere’s a breakdown of what happens when you run git push:\n\n::: {.incremental}\n1. ***Specify Remote and Branch***: You typically specify the remote repository (e.g., `origin`) and the branch you want to push (e.g., `main`).\n1. ***Upload Commits***: It uploads your local commits to the remote repository, updating the remote branch with your changes.\n1. ***Synchronize Repositories***: This ensures that the remote repository has the latest changes from your local repository.\n:::\n\n::: {.fragment}\nFor example, the command ```git push origin main``` pushes your local `main` branch to the `main` branch on the remote repository named `origin`.\n:::\n\n## Git clone\n\nThe git clone command is used to create a copy of an existing Git repository. This repository can be hosted on platforms like GitHub, GitLab, or Bitbucket, or it can reside on a local or remote server.\n\nHere’s what happens when you run git clone:\n\n::: {.incremental}\n1. **Copy Repository**: It copies all the data from the specified repository to your local machine, including the entire history and all branches.\n1. **Create Directory**: It creates a new directory named after the repository (unless you specify a different name).\n1. **Set Up Remote Tracking**: It sets up remote-tracking branches for each branch in the cloned repository, allowing you to fetch and pull updates from the original repository.\n:::\n\n::: {.fragment}\nFor example, the command `git clone https://github.com/user/repo.git` will clone the repository located at that URL into a directory named `repo`.\n:::\n\n## Branching\n\nBranches in Git are like parallel universes for your code. They allow you to:\n\n::: {.incremental}\n1. **Develop Features Independently**: You can create a new branch for each feature or bug fix. This isolates your work from the main codebase until it’s ready to be merged.\n1. **Experiment Safely**: You can try out new ideas without affecting the main project. If the experiment fails, you can simply delete the branch.\n1. **Collaborate Efficiently**: Team members can work on different branches simultaneously. Once their work is complete, branches can be merged back into the main branch (often called main or master).\n::: \n\n::: {.fragment}\nIt is a best practice when working on large software engineering projects to adopt a branching convention. A very well-used and widely adopted branching model is described in this fantastic [blog post](https://nvie.com/posts/a-successful-git-branching-model/) by Vincent Driessen.\n:::\n\n::: {.content-hidden when-profile=\"web\"}\n## Branching continued\n:::\nTo create a branch called develop that branches off of main, you run the command\n\n```{sh}\n$ git checkout -b develop main\nSwitched to a new branch \"branch\"\n```\n\nIf you are already on the main branch you can also run the command\n\n```{sh}\n$ git checkout -b develop\nSwitched to a new branch \"branch\"\n```\n\nDon't forget to add the \"-b\" flag when you create the branch.\n\n::: {.content-hidden when-profile=\"web\"}\n## Branching models\n:::\n\nThe main idea behind a branching model is to collaborate efficiently and avoid merge conflicts. You will in general have the following branches:\n\n::: {.incremental}\n- **Main branch**: Contains production ready code. This branch is only ever modified through pull requests from the develop branch.\n- **Develop branch**: Branches off from main and contains code that reflects latest delivered development changes. This branch is only ever modified through pull requests from feature branches.\n- **Feature branches**: Branch off from develop and contain code that develop new features. These branches are eventually merged back into the develop branch.\n:::\n\n\n\n## Pull requests\n\nA pull request (PR) is a way to propose changes to a codebase. When you create a pull request, you’re asking the repository maintainers to review and merge your changes into the main branch. It’s a formal way to submit your work for consideration.\n\n::: {.content-hidden when-profile=\"web\"}\n![](./figs/PullRequest1.png)\n\n![](./figs/PullRequest2.png)\n:::\n\n\n## Key Components of a Pull Request\n\n::: {.incremental}\n1. **Title and Description**: Clearly describe what the pull request does. This helps reviewers understand the purpose and scope of the changes.\n1. **Commits**: A pull request includes one or more commits that contain the actual changes. Each commit should have a meaningful message.\n1. **Diff**: This shows the differences between the source branch (where the changes were made) and the target branch (where the changes will be merged). Reviewers can see exactly what lines of code were added, modified, or deleted.\n1. **Reviewers**: You can request specific team members to review your pull request. They can leave comments, suggest changes, and approve or reject the PR.\n1. **Checks and Statuses**: Automated tests and other checks can be run on the pull request to ensure the changes don’t break anything. The status of these checks is visible in the PR.\n:::\n\n## Why Pull Requests are Important\n\n::: {.incremental}\n1. **Code Review**: Pull requests facilitate code reviews, which are essential for maintaining code quality. Reviewers can catch bugs, suggest improvements, and ensure that the code adheres to the project’s standards.\n1. **Collaboration**: They provide a structured way for team members to collaborate on code. Discussions can happen directly in the pull request, making it easier to track feedback and changes.\n1. **Documentation**: Pull requests serve as a historical record of changes. They document why certain changes were made and who approved them, which is valuable for future reference.\n1. **Integration**: Pull requests can be integrated with CI/CD pipelines to automatically run tests and deploy code, ensuring that only high-quality code is merged into the main branch.\n:::\n\n## Creating a Pull Request\n\n::: {.incremental}\n1. **Branching**: First, create a new branch for your changes.\n1. **Commit Changes**: Make your changes and commit them to your branch.\n1. **Open a PR**: Go to the repository on GitHub, navigate to the “Pull requests” tab, and click “New pull request.” Select your branch and the branch you want to merge into, then fill out the title and description.\n1. **Request Review**: Add reviewers and any necessary labels or milestones.\n1. **Address Feedback**: Reviewers will leave comments and request changes if needed. Make the necessary updates and push them to your branch.\n1. **Merge**: Once the PR is approved and all checks pass, you can merge it into the main branch.\n:::\n\n## Course repositories\n\nThe material of the course is hosted on GitHub, under [this account](https://github.com/tools4ds/DS701-Course-Notes).\n\nIn order to download a copy of the lectures and run them locally on your computer, you need to clone the lecture repository. To do that:\n\n1. Create a new folder for the course.\n```\n$ mkdir ds701\n$ cd ds701\n```\n2. Copy the clone url from the [repository's website](https://github.com/tools4ds/DS701-Course-Notes).\n3. Clone the repository from *git*.\n```\n$ git clone https://github.com/tools4ds/DS701-Course-Notes.git\n```\n\nYou should now have a directory with the course material.\n\nTo update the repository and download the **new material**, type\n\n```{sh}\n$ git pull\n```\n\n## Git Merge\n\n__How it works__: Combines the changes from one branch into another by creating a new “merge commit” that has two parent commits: \n\n- one from the current branch and \n- one from the branch being merged.\n\n:::: {.fragment}\nPros:\n\n:::: {.incremental}\n* Preserves history: Keeps the history of both branches intact, making it easy to trace back through the commit history.\n* Contextual clarity: The merge commit provides a clear indication that branches have been combined.\n::::\n::::\n\n:::: {.fragment}\nCons:\n\n:::: {.incremental}\n* Messy history: Can create a cluttered commit history with many merge commits, especially if the main branch is very active.\n::::\n::::\n\n\n## Git Rebase\n\n__How it works__: Moves or combines a sequence of commits to a new base commit. It re-applies the changes from one branch on top of another branch, effectively rewriting the project history.\n\n:::: {.fragment}\nPros:\n\n:::: {.incremental}\n* Cleaner history: Creates a linear commit history, making it easier to read and understand.\n* Simplifies debugging: A linear history simplifies the use of tools like git bisect for debugging.\n::::\n::::\n\n:::: {.fragment}\nCons:\n\n:::: {.incremental}\n* Rewrites history: Can be dangerous if not used carefully, especially on shared branches, as it rewrites commit history.\n::::\n::::\n\n## Merge vs. Rebase\n\n__Use git merge__:\n\n:::: {.incremental}\n* When you want to preserve the complete history of changes.\n* When working in a collaborative environment where multiple developers are working on the same branch.\n* When you need to resolve conflicts between branches.\n::::\n\n:::: {.fragment}\n__Use git rebase__:\n\n:::: {.incremental}\n* When you want a cleaner, linear commit history.\n* When working on a feature branch that hasn’t been shared with others yet.\n* When you need to incorporate upstream changes into your feature branch before merging it back into the main branch.\n::::\n::::\n\n## Exercise\n\nHere's an exercise to get you started with GitHub and practice the concepts we have covered so far.\n\nGo to your page on GitHub, e.g. `https://github.com/your-github-username`.\n\nClick on the `+` on the upper right corner of the page and select `New repository`.\n\nCall it \"learn-github\".\n\nLeave the repository public.\n\nSelect the checkbox `Add a README file`.\n\nClick on `Create repository`.\n\n> Because we created this repository with a README file, GitHub automatically added it to the repository and so the\n> repository is not empty. \n\nTo clone the repository, click on `<> Code` and copy the URL.\n\nThen, clone the repository from *git*.\n\n```{sh}\n$ git clone https://github.com/your-github-username/learn-github.git\n$ cd learn-github\n```\n\nNow you can start working on the repository.\n\nTry:\n\n1. Create a new branch\n2. Add a new file text file to the repository and add some text to it.\n3. Add and commit the changes.\n4. Push the changes to the repository.\n5. Create a pull request.\n6. Merge the pull request and delete the branch on GitHub.\n7. Pull the changes to your local repository.\n8. Delete the branch from your local repository.\n\n## Recap\n\nIn this lecture, we covered the following topics:\n\n::: {.incremental}\n1. Configuring git\n1. Creating a repository\n1. Staging and committing files\n1. Modifying files\n1. Recovering old versions\n1. Branching\n1. Pull requests\n1. Merge vs. Rebase\n:::\n\n",
    "supporting": [
      "02A-Git_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}