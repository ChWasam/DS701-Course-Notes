{
  "hash": "2495853d59a02986d3bf7d0ccdcc307b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Introduction to Networks\njupyter: python3\n---\n\n\n\n\n[![](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/tools4ds/DS701-Course-Notes/blob/main/ds701_book/jupyter_notebooks/21-Networks-I.ipynb)\n\n::: {#70c9c506 .cell hide_input='true' slideshow='{\"slide_type\":\"skip\"}' tags='[\"hide-input\"]' execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nimport scipy as sp\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib as mp\nimport sklearn\nimport networkx as nx\nfrom IPython.display import Image, HTML\n\nimport laUtilities as ut\n\n%matplotlib inline\n```\n:::\n\n\nNow we will encounter a new kind of data: __networks__, also called __graphs.__\n\n(We're going to use the two terms interchangeably).\n\n## Basic Definitions\n\nA graph is a pair $(V, E)$ where $V$ is a set of __vertices__ and $E$ is a set of vertex pairs called __edges.__\n\nWe'll also use the term __nodes__ for vertices,\n\nand we'll use the term __links__ for edges.\n\nWe'll distinguish between __undirected__ graphs and __directed__ graphs.\n\nIn an underdirected graph, an edge $(u, v)$ is an unordered pair.  The edge $(v, u)$ is the same thing.\n\nIn a directed graph, $(u, v)$ is an ordered pair, and it is different from $(v, u)$.\n\n::: {#830dcbba .cell hide_input='true' slideshow='{\"slide_type\":\"fragment\"}' tags='[\"hide-input\"]' execution_count=3}\n``` {.python .cell-code}\nG = nx.Graph()\nG.add_edges_from([(1,2), (1,3), (2, 3), (3, 4), (3, 5)])\nDG = nx.DiGraph()\nDG.add_edges_from([(1,2), (1,3), (2, 3), (3, 4), (3, 5)])\npos = {\n    1: [0, 0],\n    2: [-1, -1],\n    3: [1, -1],\n    4: [1, 0],\n    5: [2, 0]\n}\nfig = plt.figure(figsize = (12, 4))\nax1 = fig.add_subplot(121)\nnx.draw_networkx(G, \n                 ax = ax1,\n                 node_size=300, \n                 edge_color='k',\n                 node_color = 'lightcoral', \n                 pos = nx.spring_layout(G, seed = 1),\n                 with_labels=True, \n                 alpha=1, linewidths=2)\nplt.axis('off')\nplt.title('Undirected Graph', size = 16)\nax2 = fig.add_subplot(122)\nnx.draw_networkx(DG, \n                 ax = ax2,\n                 node_size=300, \n                 edge_color='k',\n                 node_color = 'lightblue',\n                 pos = pos,\n                 with_labels=True, \n                 arrowsize = 25,\n                 alpha=1, linewidths=2)\nplt.title('Directed Graph', size = 16)\nplt.axis('off');\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-html/cell-3-output-1.png){width=912 height=339}\n:::\n:::\n\n\nA __path__ in a graph from $u$ to $v$ is a sequence of edges that starts at $u$ and ends at $v$.\n\nIn a directed graph, all of the edges in a path need to be oriented head-to-tail.\n\nIf there is a path from $u$ to $v$, we say that $v$ is __reachable__ from $u$.\n\n### Degree\n\nThe __degree__ of a node is the number of edges that connect to it.\n\nIn a directed graph, we distinguish between:\n* __in-degree__: the number of incoming edges to the node\n* __out-degree__: the number of outgoing edges to the node\n\n::: {#2b484575 .cell hide_input='true' slideshow='{\"slide_type\":\"fragment\"}' tags='[\"hide-input\"]' execution_count=4}\n``` {.python .cell-code}\nG = nx.Graph()\nG.add_edges_from([(1,2), (1,3), (2, 3), (3, 4), (3, 5)])\nDG = nx.DiGraph()\nDG.add_edges_from([(1,2), (1,3), (2, 3), (3, 4), (3, 5)])\npos = {\n    1: [0, 0],\n    2: [-1, -1],\n    3: [1, -1],\n    4: [1, 0],\n    5: [2, 0]\n}\nfig = plt.figure(figsize = (12, 4))\nax1 = fig.add_subplot(121)\nnx.draw_networkx(G, \n                 ax = ax1,\n                 node_size=300, \n                 edge_color='k',\n                 node_color = 'lightcoral', \n                 pos = nx.spring_layout(G, seed = 1),\n                 with_labels=True, \n                 alpha=1, linewidths=2)\nplt.axis('off')\nplt.title('Undirected Graph', size = 16)\nax2 = fig.add_subplot(122)\nnx.draw_networkx(DG, \n                 ax = ax2,\n                 node_size=300, \n                 edge_color='k',\n                 node_color = 'lightblue',\n                 pos = pos,\n                 with_labels=True, \n                 arrowsize = 25,\n                 alpha=1, linewidths=2)\nplt.title('Directed Graph', size = 16)\nplt.axis('off');\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-html/cell-4-output-1.png){width=912 height=339}\n:::\n:::\n\n\nThe __neighbors__ of a node are the nodes to which it is connected.\n\nSo the degree of a node is the number of neighbors it has.\n\nNode that in a network with $n$ nodes and $e$ edges, the average node degree is $2e/n$.  \n\nMake sure that this is obvious to you!\n\n### Connectivity\n\nThe first question to ask about a graph is: is it __connected__?\n\nFor an undirected graph to be connected, for each pair of nodes $(u, v)$, $u$ is reachable from $v$.\n\nWe say a directed graph is connected when its undirected version is connected.\n\n::: {#062a416d .cell hide_input='true' slideshow='{\"slide_type\":\"fragment\"}' tags='[\"hide-input\"]' execution_count=5}\n``` {.python .cell-code}\nG = nx.Graph()\nG.add_edges_from([(1,2), (1,3), (2, 3)])\nG.add_node(4)\nG.add_node(5)\nDG = nx.Graph()\nDG.add_edges_from([(1,2), (3, 1), (2, 3), (3, 4), (3, 5)])\npos = {\n    1: [0, 0],\n    2: [-1, -1],\n    3: [1, -1],\n    4: [1, 0],\n    5: [2, 0]\n}\nfig = plt.figure(figsize = (12, 4))\nax1 = fig.add_subplot(121)\nnx.draw_networkx(G, \n                 ax = ax1,\n                 node_size=300, \n                 edge_color='k',\n                 node_color = 'lightblue', \n                 pos = pos,\n                 with_labels=True, \n                 arrowsize = 25,\n                 alpha=1, linewidths=2)\nplt.axis('off')\nplt.title('Not Connected', size = 16)\nax2 = fig.add_subplot(122)\nnx.draw_networkx(DG, \n                 ax = ax2,\n                 node_size=300, \n                 edge_color='k',\n                 node_color = 'lightcoral',\n                 pos = pos,\n                 with_labels=True, \n                 arrowsize = 25,\n                 alpha=1, linewidths=2)\nplt.title('Connected', size = 16)\nplt.axis('off');\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/Users/tomg/Source/courses/tools4ds/DS701-Course-Notes/.venv/lib/python3.12/site-packages/networkx/drawing/nx_pylab.py:312: UserWarning: \n\nThe arrowsize keyword argument is not applicable when drawing edges\nwith LineCollection.\n\nTo make this warning go away, either specify `arrows=True` to\nforce FancyArrowPatches or use the default values.\nNote that using FancyArrowPatches may be slow for large graphs.\n\n  draw_networkx_edges(G, pos, arrows=arrows, **edge_kwds)\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-html/cell-5-output-2.png){width=912 height=339}\n:::\n:::\n\n\nIf the graph is not connected, it may contain __connected components__.   \n\nA connected component is a subgraph that is connected.\n\nIn a directed graph, we can also ask if it is __strongly connected.__\n\nA directed graph is strongly connected if there is a (directed) path between any two nodes.\n\nThat is, any node is reachable from any other node.\n\nWithin a directed graph, only a subset of nodes may be strongly connected.\n\nThese are called the __strongly connected component__ (SCC).\n\n::: {#d1b7cb9a .cell hide_input='true' slideshow='{\"slide_type\":\"fragment\"}' tags='[\"hide-input\"]' execution_count=6}\n``` {.python .cell-code}\nG = nx.DiGraph()\nG.add_edges_from([(1,2), (1,3), (2, 3), (3, 4), (3, 5)])\nDG = nx.DiGraph()\nDG.add_edges_from([(1,2), (3, 1), (2, 3), (3, 4), (3, 5)])\npos = {\n    1: [0, 0],\n    2: [-1, -1],\n    3: [1, -1],\n    4: [1, 0],\n    5: [2, 0]\n}\nfig = plt.figure(figsize = (12, 4))\nax1 = fig.add_subplot(121)\nnx.draw_networkx(G, \n                 ax = ax1,\n                 node_size=300, \n                 edge_color='k',\n                 node_color = 'lightblue', \n                 pos = pos,\n                 with_labels=True, \n                 arrowsize = 25,\n                 alpha=1, linewidths=2)\nplt.axis('off')\nplt.title('No SCC', size = 16)\nax2 = fig.add_subplot(122)\nnx.draw_networkx(DG, \n                 ax = ax2,\n                 node_size=300, \n                 edge_color='k',\n                 node_color = ['lightcoral', 'lightcoral', 'lightcoral', 'lightblue', 'lightblue'],\n                 pos = pos,\n                 with_labels=True, \n                 arrowsize = 25,\n                 alpha=1, linewidths=2)\nplt.title('Has a SCC', size = 16)\nplt.axis('off');\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-html/cell-6-output-1.png){width=912 height=339}\n:::\n:::\n\n\n## Characterizing Graphs\n\nWhen you first start working with a network, there are some basic questions that are very helpful to ask.\n\nIt is helpful to characterize the degrees, components, and other structures in the graph.\n\n### Comparison Case: the $G(n, p)$ Random Graph\n\nIn studying real-world graphs, it is helpful to have a case to compare against.\n\nThe most common comparison is the __$G(n, p)$ random graph__.   It is also called the __Erdős–Rényi__ graph, after the two mathematicians who developed and studied it.\n\nThe $G(n, p)$ random graph model is very simple:  \n* we start with a set of $n$ nodes\n* for each pair of nodes, we connect them with probability $p$.\n\nIt is easy to see that in this graph, the average node degree is $np$.\n\n::: {#38b1f317 .cell hide_input='true' slideshow='{\"slide_type\":\"fragment\"}' tags='[\"hide-input\"]' execution_count=7}\n``` {.python .cell-code}\nn = 35\np = 0.15\ner = nx.erdos_renyi_graph(n, p, seed = 0)\nplt.figure(figsize = (12, 8))\nnx.draw_networkx(er, node_size=45, \n                 edge_color='gray', \n                 pos = nx.spring_layout(er, seed = 1),\n                 with_labels=False, alpha=1, linewidths=2)\nplt.axis('off')\nplt.title(f'$G(n, p)$ with $n$ = {n} and $p$ = {p:0.2f}', size = 16);\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-html/cell-7-output-1.png){width=912 height=636}\n:::\n:::\n\n\nIn this graph, the average degree is $np = 35 \\cdot 0.15 = 5.25$\n\nAs it turns out, most real-world graphs do __not__ match the properties of $G(n, p)$ graphs.  \n\nBut it is useful to have a comparison to a \"random\" graph.\n\n### Degree Distributions\n\nUnderstanding connectivity starts with asking about observed degrees in the graph.\n\nThis is captured in the __degree distribution.__\n\n$$ P[D > x] = \\text{probability that a node has degree at least } x $$\n\nWe typically focus our attention on large values of $x$ -- nodes that are highly connected.\n\n#### Power Law Degree Distributions\n\nIt's common for a degree distribution to __approximately__ follow a power-law.\n\nThe simplest power-law distribution is called the Pareto distribution:\n\n$$ P[D > x] = k^{\\alpha} x^{-\\alpha}\\;\\;\\; k \\leq x,\\; \\;0 < \\alpha\n\\leq 2. $$\n\nIt takes on values in the range $[k, \\infty]$. \n\n::: {#07b48849 .cell hide_input='true' slideshow='{\"slide_type\":\"fragment\"}' tags='[\"hide-input\"]' execution_count=8}\n``` {.python .cell-code}\nfrom scipy.stats import pareto\nalpha = 1.3\nx = np.linspace(pareto.ppf(0.005,alpha), pareto.ppf(0.995,alpha), 100)\nplt.figure(figsize = (8, 6))\nplt.plot(x, pareto.pdf(x,alpha),'b-', lw = 5, alpha = 0.6, label='pareto pdf')\nplt.title(r'Pareto PDF.  $\\alpha$ = {}'.format(alpha), size=16)\nplt.xlabel('$x$', size=14)\nplt.ylabel('$p(x)$', size=14);\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-html/cell-8-output-1.png){width=671 height=533}\n:::\n:::\n\n\nWe've seen distributions like this before when looking at recommender system data.\n\nIn a distribution like this, almost all values are very small, \n\nbut there is a non-negligible fraction of values that are __very__ large.\n\nThis is like \"grains of sand\" mixed with a few \"boulders.\"\n\nThis is also referred to as \"elephants and mice.\"\n\nWhat does this mean for node degree?\n\nIt means that \n* most nodes have __few neighbors,__ but\n* an important small subset of nodes have __many, many neighbors.__\n\nTo capture such high-variable degree distributions, a common strategy is to plot them on __log-log__ axes.\n\nOn log-log axes, a Pareto distribution appears as a straight line:\n\n::: {#b370c4c3 .cell hide_input='true' tags='[\"hide-input\"]' execution_count=9}\n``` {.python .cell-code}\nfrom scipy.stats import pareto\nalpha = 1.3\nplt.figure(figsize = (8, 6))\nx = np.linspace(pareto.ppf(0.005,alpha), pareto.ppf(0.995,alpha), 100)\nplt.plot(np.log10(x), np.log10(pareto.pdf(x,alpha)),'b-', lw = 5, alpha = 0.6, label='pareto pdf')\nplt.title(r'Pareto PDF.  $\\alpha$ = {}'.format(alpha), size=16)\nplt.xlabel('$\\log_{10}(x)$', size=14)\nplt.ylabel('$\\log_{10}(p(x))$', size=14);\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n<>:7: SyntaxWarning: invalid escape sequence '\\l'\n<>:8: SyntaxWarning: invalid escape sequence '\\l'\n<>:7: SyntaxWarning: invalid escape sequence '\\l'\n<>:8: SyntaxWarning: invalid escape sequence '\\l'\n/var/folders/ly/jkydg4dj2vs93b_ds7yp5t7r0000gn/T/ipykernel_16909/817710779.py:7: SyntaxWarning: invalid escape sequence '\\l'\n  plt.xlabel('$\\log_{10}(x)$', size=14)\n/var/folders/ly/jkydg4dj2vs93b_ds7yp5t7r0000gn/T/ipykernel_16909/817710779.py:8: SyntaxWarning: invalid escape sequence '\\l'\n  plt.ylabel('$\\log_{10}(p(x))$', size=14);\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-html/cell-9-output-2.png){width=682 height=535}\n:::\n:::\n\n\n#### Power Law Degree Distributions are Ubiquitous\n\n<center>\n    \n<img src=\"figs/L21-newman-powerlaws.png\" alt=\"Figure\" width=\"800px\">\n    \n</center>\n\n> The networks shown are: (a) the collaboration network of mathematicians [182]; (b) citations between 1981 and 1997 to all papers cataloged by the Institute for Scientific Information [351]; (c) a 300 million vertex subset of the World Wide Web, circa 1999 [74]; (d) the Internet at the level of autonomous systems, April 1999 [86]; (e) the power grid of the western United States [416]; (f) the interaction network of proteins in the metabolism of the yeast S. Cerevisiae [212]. \n>\n> _The structure and function of complex networks,_ M. E. J. Newman\n>\n> https://arxiv.org/abs/cond-mat/0303516\n\nNote that $G(n, p)$ random graphs do __not__ have power-law degree distributions.\n\nTheir degree distributions have exponential tails (like the power grid example above.)\n\n### Clustering\n\nThe next important property of a network to understand is __clustering__.  \n\nIn the context of networks, clustering refers to the tendency for groups of nodes to have higher connectivity within the group than the network-wide average.\n\nThe simplest measure of local clustering is __clustering coefficient__.\n\nThe clustering coefficient is the answer to the question \"are my friends themselves friends?\"\n\nIn other words, do the neighbors of a node tend to be neighbors?\n\nMore specifically, clustering coefficient measures the __probability that two of your neighbors are connected.__ \n\nThere are two ways one can measure this:\n\n$$C^{(1)} = \\frac{\\sum_i \\text{number of triangles that include }i}{\\sum_i \\text{number of pairs of neigbors of }i} $$\n\nThis is the ratio of the mean triangle count to mean neighbor pair count.\n\nIt is the probability that a __random pair__ of neighbors are connected.\n\n::: {#cf4fe619 .cell hide_input='true' slideshow='{\"slide_type\":\"fragment\"}' tags='[\"hide-input\"]' execution_count=10}\n``` {.python .cell-code}\nG = nx.Graph()\nG.add_edges_from([(1,2), (1,3), (2, 3), (3, 4), (3, 5)])\nplt.figure(figsize = (6, 4))\nnx.draw_networkx(G, node_size=300, \n                 edge_color='k', \n                 pos = nx.spring_layout(G, seed = 1),\n                 with_labels=False, alpha=1, linewidths=2)\nplt.axis('off');\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-html/cell-10-output-1.png){width=466 height=315}\n:::\n:::\n\n\n$$C^{(1)} = \\frac{3}{1 + 1 + 6} = \\frac{3}{8} = 0.375$$\n\nThe second way to measure clustering coefficient is the mean of the ratios:\n    \n$$ C^{(2)} = \\frac{1}{n} \\sum_i \\frac{\\text{number of triangles that include }i}{\\text{number of pairs of neigbors of }i} $$\n\nThis is the probability that neighbors are connected for a __random node.__\n\n$$ C^{(2)} = \\frac{1}{5} (1 + 1 + \\frac{1}{6}) = \\frac{13}{30} = 0.433$$\n\nWhat is the clustering coefficient in a $G(n, p)$ random graph?\n\nThis is easy: the probability that two of your neighbors are connected is the same as the probability that __any__ two nodes are connected.\n    \nIn other words, $C^{(1)} = C^{(2)} = p$.\n\n__Real World Graphs Tend to Show Large Amounts of Clustering.__\n\nIn practice one finds that real world graphs show strong clustering.\n\nFor example, consider a social network.  Your friends are much more likely to be themselves friends than two randomly chosen people.\n\n<center>\n    \n<img src=\"figs/L21-clustering-coefs.png\" alt=\"Figure\" width=\"800px\">\n    \n</center>\n\n## Clustering and Path Length: Small Worlds\n\nThe strong presence of clustering in networks leads to a question: how long is a typical shortest path between nodes?\n    \nThe average shortest path length between nodes is one way to measure a network's \"diameter.\"\n\nLet's consider a highly clustered graph:\n\n<center>\n    \n<img src=\"figs/L21-high-clustering.png\" alt=\"Figure\" width=\"300px\">\n    \n</center>\n\nIn this graph, each node has four neighbors, and of the 6 pairs of neighbors, 3 are connected.\n\nSo the clustering coefficient is 0.5, quite high.\n\nWhat is the average shortest path between nodes?   \n\nIt seems to be around $n/8$ - on average you go 1/4 of the way around the circle, in hops of 2.\n\nSo the path length grows linearly with $n$. \n\n__If the number of nodes is large, the average path length is large.__\n\nNow, we know that real-world social networks are highly clustered,\n\nSo, based on this model, we might assume that the average path length between two people in a large social network is going to be quite large.\n\nIs this true?   If you choose two people at random from the population of the United States (say), is the shortest path length between them long?\n\nIn 1967 the social psychologist Stanley Milgram set out to empirically answer this question.\n<p>\n<center>\n    \n<img src=\"figs/Stanley_Milgram_Profile.jpeg\" alt=\"Figure\" width=\"200px\">\n    \n</center>\n\nMilgram picked 160 people at random in Omaha, Nebraska.  (It helped that there used to be phone books.)\n\nHe asked them to get a letter to a particular person, a stockbroker in Boston.\n\nThe rules that he set were that they could only pass the letter between friends that were known on a first-name basis.\n\nSurprisingly, 62 of the letters made it to the stockbroker!\n\nMore surprising was the fact that the __average path length was 6.2 people!__\n\nThis statistic became famous when John Guare wrote a play called _Six Degrees of Separation._\n\nGiven what we know about clustering in social networks, this is quite surprising.   How can we explain it?\n\nThe first clue comes from another classic social science paper, called _The Stength of Weak Ties,_ by Mark Granovetter.\n\nThis is sometimes referred to as the most famous paper in sociology (60,000 citations!).   \n\nGranovetter interviewed people about how the found their jobs.  He found that most people did not get a job through someone that was a close friend, but rather through a __distant__ acquaintance.\n\nThis suggests that an important way that information travels in a social network is via the rare connections that exist __outside__ of the local clustering of friendships.\n\nThis was all put on an experimental basis in __another__ classic paper, by the social scientist Duncan Watts and the mathematician Steve Strogatz.\n<center>\n    \n<img src=\"figs/duncan_watts.jpeg\" alt=\"Figure\" width=\"200px\" align=\"left\">\n<img src=\"figs/steven-strogatz.png\" alt=\"Figure\" width=\"200px\" align=\"left\">\n    \n</center>\n\nIn their paper _Collective Dynamics of Small-World Networks_, Watts and Strogatz perfomed an elegant experiment.\n\nThey asked: if we take a highly clustered network, and slightly perturb it (randomize it), what happens?\n\nSpecifically, they started with a network in which each node is connected to a fixed number of neighbors, and connections are made in a __highly clustered__ way.\n\n<center>\n    \n<img src=\"figs/L21-watts-strogatz.png\" alt=\"Figure\" width=\"60%\">\n    \n</center>\n\nThen, with probability $p$, __rewire__ each edge: change it to connect to a __random__ destination.\n\n\nSo, as $p$ varies, what happens to:\n* Average path length $L(p)$ and\n* Clustering coefficient $C(p)$?\n\nAnd here is the famous figure from that paper:\n   \n<center>\n    \n<img src=\"figs/watts-strogatz-2.png\" alt=\"Figure\" width=\"700px\">\n    \n</center> \n\nNotice the log scale on the $p$ axis.\n\nWhat Watts and Strogatz showed is that __it only takes a small amount of long-range connections__ to dramatically shrink the average path length between nodes.\n\nThey showed that high clustering and short path lengths can coexist.  They called networks with high clustering and short path lengths __small world networks.__\n\nOnce this phenomenon is understood, we see that it shows up repeatedly.\n\nFor example, consider the network of movie actors:  two actors are connected if they appear in the same movie.\n\nThus we have the phenomenon of the __six degrees of Kevin Bacon__:\n<p>\n    \n<center>\n    \n<img src=\"figs/L21-six-degrees-bacon.png\" alt=\"Figure\" width=\"700px\">\n    \n</center> \n\nYou can try your luck at [The Oracle of Bacon](https://oracleofbacon.org/movielinks.php).\n\nFor example, Elvis Presley:\n\n<center>\n    \n<img src=\"figs/L21-oracle-bacon.png\" alt=\"Figure\" width=\"300px\">\n    \n</center> \n\nWhat's special about Kevin Bacon?\n\nNot really anything.  \n\nBecause movie co-appearance forms a small world network, most any path between two actors is a short one.\n\n__Implications of Small Worlds.__\n\nViruses spread rapidly in small worlds.  \n\nOne of the goals of pandemic lockdowns is to keep people circulating in their local social groups, and to eliminate the effect of long-range (weak-tie) connections.\n\nThis is the idea behind travel bans and mandatory quarantining after travel.\n\nHere is a figure showing the effect on virus propagation of deleting most of the long-range edges from a small-world network:\n\n<p>\n    \n<center>\n    \n<img src=\"figs/L21-covid-mitigation.png\" alt=\"Figure\" width=\"600px\">\n    \n</center> \n\nDifferent curves correspond to when the lockdown is deployed (after how many deaths).\n    \nFrom [_Mitigating COVID-19 on a Small-World Network_,](https://www.nature.com/articles/s41598-021-99607-z) Marvin Du, Scientific Reports Oct 2021.\n\nAnother question concerns how \"shortcuts\" arise.\n\nRemember that node degree distributions are typically power-law.\n\nSo although most people have small acquaintance sets, a small subset of people are very highly connected.\n\n<center>\n    \n<img src=\"figs/F2.large.jpeg\" alt=\"Figure\" width=\"500px\">\n    \n</center> \n\nThese \"high social capital\" individuals play a big role in creating long-range, path-shortening connections in social networks.\n\n## Analyzing Graphs\n\nWhen first starting to work with a network, understanding its properties can be difficult.\n\nClustering and the presence of high-degree nodes both contribute to the problem.\n\nNonetheless, there are a number of strategies that are used to \"get to know\" a new network dataset.\n\nThey include:\n* visualize the network in a way that communicates as much insight as possible, and\n* compute important metrics of the network \n\n### Visualizing Networks\n\nAs an example, we'll use the following network.\n\nIt records American football games between NCAA Div IA colleges in Fall 2000 (available [here](http://www-personal.umich.edu/~mejn/netdata/)). \n\nEach vertex represents a football team, which belongs to a specific conference (Big Ten, Conference USA, Pac-10, etc.). \n\nAn edge between two vertices $v_1$ and $v_2$ means that the two teams played each other; the weight of the edge ($v_1$, $v_2$) is equal to the number of times they played each other.\n\n(Data from  M. Girvan and M. E. J. Newman,\n_Community structure in social and biological networks,_\nProc. Natl. Acad. Sci. USA 99, 7821-7826 (2002).)\n\n::: {#8a8bd04a .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=11}\n``` {.python .cell-code}\n# data from http://www-personal.umich.edu/~mejn/netdata/                                \nfootball = nx.readwrite.gml.read_gml('data/football.gml')\n```\n:::\n\n\n::: {#a7d75b39 .cell hide_input='true' slideshow='{\"slide_type\":\"fragment\"}' execution_count=12}\n``` {.python .cell-code}\nprint(f'The football network has {len(football.nodes())} nodes and {len(football.edges())} edges')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe football network has 115 nodes and 613 edges\n```\n:::\n:::\n\n\nTo get a sense of what is unusual here, we can compare this network to a $G(n, p)$ random network with the same number of nodes and edges:\n\n::: {#bfa51572 .cell hide_input='false' execution_count=13}\n``` {.python .cell-code}\nn = len(football.nodes())\ne = len(football.edges())\np = e / ((n * (n-1))/2)\nF_random = nx.erdos_renyi_graph(n, p, seed = 0)\n```\n:::\n\n\nOne way to visualize is to use a circular layout, which keeps all the edges in the interior. \n\nThis can make things easier to see sometimes.\n\n::: {#f1d6a353 .cell hide_input='true' tags='[\"hide-input\"]' execution_count=14}\n``` {.python .cell-code}\nplt.figure(figsize = (18, 8))\nax1 = plt.subplot(121)\nnx.draw_networkx(football, ax = ax1,\n                 node_size=35, \n                 edge_color='gray', \n                 pos = nx.circular_layout(football),\n                 with_labels=False, alpha=.8, linewidths=2)\nplt.axis('off')\nplt.title('Title 1 Football -- Circular Layout', size = 16)\nax2 = plt.subplot(122)\nnx.draw_networkx(F_random, ax = ax2,\n                 node_size=35, \n                 edge_color='gray', \n                 pos = nx.circular_layout(F_random),\n                 with_labels=False, alpha=.8, linewidths=2)\nplt.axis('off')\nplt.title('Same Density Random -- Circular Layout', size = 16);\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-html/cell-14-output-1.png){width=1358 height=635}\n:::\n:::\n\n\nThere is some non-random structure here, but it's not clear exactly what it is.\n\nSo we will turn to a more informative layout.\n\nThe standard `networkx` routine uses what is called a 'spring' layout. \n\nHere is how 'spring' layout works:\n* Each edge has a `weight` parameter (could be 1 for all edges).  \n* The layout routine fixes \n    * a spring of length = 1/`weight` between the nodes, and \n    * a repulsive force between each pair of nodes, \n* and then lets the set of all forces reach its minimum energy state.  \n\nThis is a kind of minimal distortion in a least-squares sense.\n\n::: {#7dfa6d22 .cell hide_input='true' slideshow='{\"slide_type\":\"fragment\"}' tags='[\"hide-input\"]' execution_count=15}\n``` {.python .cell-code}\nplt.figure(figsize = (18, 8))\nax1 = plt.subplot(121)\nnx.draw_networkx(football, ax = ax1,\n                 node_size=35, \n                 edge_color='gray', \n                 pos = nx.spring_layout(football, seed = 0),\n                 with_labels=False, alpha=.8, linewidths=2)\nplt.axis('off')\nplt.title('Title 1 Football -- Spring Layout', size = 16)\nax2 = plt.subplot(122)\nnx.draw_networkx(F_random, ax = ax2,\n                 node_size=35, \n                 edge_color='gray', \n                 pos = nx.spring_layout(F_random, seed = 0),\n                 with_labels=False, alpha=.8, linewidths=2)\nplt.axis('off')\nplt.title('Same Density Random -- Spring Layout', size = 16);\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-html/cell-15-output-1.png){width=1358 height=635}\n:::\n:::\n\n\nNotice how the spring layout tends to bring clusters of densely connected nodes close to each other.\n\nFinally, we can try the spectral layout.\n\n(We will define the spectral layout in the next lecture.)\n\n::: {#acae4764 .cell hide_input='true' slideshow='{\"slide_type\":\"fragment\"}' tags='[\"hide-input\"]' execution_count=16}\n``` {.python .cell-code}\nplt.figure(figsize = (18, 8))\nax1 = plt.subplot(121)\nnx.draw_networkx(football, ax = ax1,\n                 node_size=35, \n                 edge_color='gray', \n                 pos = nx.spectral_layout(football),\n                 with_labels=False, alpha=.8, linewidths=2)\nplt.axis('off')\nplt.title('Title 1 Football -- Spectral Layout', size = 16)\nax2 = plt.subplot(122)\nnx.draw_networkx(F_random, ax = ax2,\n                 node_size=35, \n                 edge_color='gray', \n                 pos = nx.spectral_layout(F_random),\n                 with_labels=False, alpha=.8, linewidths=2)\nplt.axis('off')\nplt.title('Same Density Random -- Spectral Layout', size = 16);\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-html/cell-16-output-1.png){width=1358 height=635}\n:::\n:::\n\n\nWith this layout, we can start to understand the structure of the network --\n\nsee clusters of teams that correspond to conferences, --\n\nand understand that there are not too many high-degree nodes.\n\n### Characterizing Graphs\n\nAnother way to undersand network structured data is to look at important metrics.\n\nFor example, we can start with __clustering coefficient:__\n\n::: {#04f00c80 .cell hide_input='false' slideshow='{\"slide_type\":\"-\"}' execution_count=17}\n``` {.python .cell-code}\nclustering_coefficient = nx.average_clustering(football)\nprint(f'The clustering coefficient of the Football network is {clustering_coefficient:0.3f}')\ncc_random = nx.average_clustering(F_random)\nprint(f'The clustering coefficient for the equivalent random network is {cc_random:0.3f}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe clustering coefficient of the Football network is 0.403\nThe clustering coefficient for the equivalent random network is 0.088\n```\n:::\n:::\n\n\nAnother useful metric is diameter:\n\n::: {#d3b759de .cell slideshow='{\"slide_type\":\"-\"}' execution_count=18}\n``` {.python .cell-code}\nprint(f'The diameter of the Football network is {nx.diameter(football)}' +\n      f' and the average shortest path length is {nx.average_shortest_path_length(football):0.3f}')\nprint(f'The diameter of the equivalent random network is {nx.diameter(F_random)}' +\n      f' and the average shortest path length is {nx.average_shortest_path_length(F_random):0.3f}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe diameter of the Football network is 4 and the average shortest path length is 2.508\nThe diameter of the equivalent random network is 4 and the average shortest path length is 2.215\n```\n:::\n:::\n\n\nThe next property we can look at is the __degree distribution:__\n\n::: {#81b26a62 .cell hide_input='false' slideshow='{\"slide_type\":\"fragment\"}' execution_count=19}\n``` {.python .cell-code}\ndegree_freq = nx.degree_histogram(football)\ndegrees = np.array(range(len(degree_freq)))\n```\n:::\n\n\n::: {#1e375e4f .cell hide_input='true' tags='[\"hide-input\"]' execution_count=20}\n``` {.python .cell-code}\nplt.figure(figsize = (8, 6))\nplt.bar(degrees, degree_freq)\nplt.xlabel('Degree', size = 14)\nplt.ylabel('Number of Nodes', size = 14)\nplt.title('Degree Distribution of Football Network', size = 16);\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-html/cell-20-output-1.png){width=665 height=533}\n:::\n:::\n\n\nTo get a sense of what is unusual here, we can again compare this to the equivalent random network:\n\n::: {#18e398de .cell hide_input='true' tags='[\"hide-input\"]' execution_count=21}\n``` {.python .cell-code}\nrand_degree_freq = nx.degree_histogram(F_random)\nrand_degrees = range(len(rand_degree_freq))\nplt.figure(figsize = (8, 6))\nplt.bar(rand_degrees, rand_degree_freq, 0.425, label = 'Random')\nplt.bar(degrees+0.5, degree_freq, 0.425, label = 'Actual')\nplt.xlabel('Degree', size = 14)\nplt.ylabel('Number of Nodes', size = 14)\nplt.legend(loc = 'best', fontsize = 14)\nplt.title('Degree Distribution of Football Network\\nCompared to Random', size = 16);\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-html/cell-21-output-1.png){width=674 height=558}\n:::\n:::\n\n\nWe can see the evidence of scheduling of games in this distribution: a much larger number of teams plays 11 games than would occur by chance.\n\n",
    "supporting": [
      "21-Networks-I_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}