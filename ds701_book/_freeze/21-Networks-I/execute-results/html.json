{
  "hash": "cebbb51458cdb10ca8519891d2252bb7",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Introduction to Networks\njupyter: python3\n---\n\n\n# Networks\n[![](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/tools4ds/DS701-Course-Notes/blob/main/ds701_book/jupyter_notebooks/21-Networks-I.ipynb)\n\n\n\nWe now consider a new kind of data, __networks__, which are represented by __graphs.__\n\n## Motivation\n\nGraphs allow us to represent and analyze complex relationships and structures in data. \n\nBy using nodes (vertices) and edges (connections), graphs can model various types of relationships and interactions, making it easier to visualize and understand the underlying patterns.\n\n## Example Applications in Machine Learning\n\n- **Social Network Analysis**\n  - Model social networks with nodes representing individuals and edges representing relationships or interactions.\n  - Understand community structures, influence, and information spread.\n\n- **Biological Network Analysis**\n  - Model biological systems, such as protein-protein interaction networks.\n  - Understand cellular processes and disease mechanisms.\n\n- **Knowledge Graphs**\n  - Store and retrieve structured information.\n  - Enable better search and question-answering systems.\n\n::: {.content-visible when-profile=\"web\"}\n- **Natural Language Processing (NLP)**\n  - Use dependency parsing to represent the grammatical structure of sentences.\n  - Aid in tasks like machine translation and sentiment analysis.\n\n- **Recommendation Systems**\n  - Use graph-based algorithms like collaborative filtering.\n  - Recommend products or content by analyzing relationships between users and items.\n\n- **Fraud Detection**\n  - Detect fraudulent activities by identifying unusual patterns and connections in financial transactions.\n:::\n\n## Graphs\n\nA graph $G=(V, E)$ is a pair, where $V$ is a set of __vertices__, and $E$ is a set of unordered vertex pairs $(u, v)$ called __edges__.\n\nThe term __nodes__ is also used for vertices. The term __links__ or __connections__ is also used for edges.\n\nWe'll distinguish between __undirected__ graphs and __directed__ graphs.\n\n## Undirected Graphs\n\nIn an undirected graph, an edge $(u, v)$ is an unordered pair. The edge $(v, u)$ is the same thing.\n\nThere are no orientations in an undirected graph.\n\n::: {#5ac7a8e6 .cell execution_count=3}\n``` {.python .cell-code}\n# Create an undirected graph\nG = nx.Graph()\nG.add_edges_from([(1, 2), (1, 3), (2, 3), (3, 4), (3, 5)])\n\n# Plot the undirected graph\nplt.figure(figsize=(6, 4))\nnx.draw_networkx(G,\n                 node_size=300,\n                 edge_color='k',\n                 node_color='lightcoral',\n                 pos=nx.spring_layout(G, seed=1),\n                 with_labels=True,\n                 alpha=1, linewidths=2)\nplt.axis('off')\nplt.title('Undirected Graph', size=16)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-revealjs/cell-3-output-1.png){width=466 height=339 fig-align='center'}\n:::\n:::\n\n\n## Directed Graphs\n\nIn a directed graph, $(u, v)$ is an ordered pair and it is different from $(v, u)$.\n\nThis means that the edges have an orientation. This orientation is indicated by arrows. \n\nFor example, the edge $(1, 2)$, is directed from node 1 to node 2.\n\n::: {#f2880b80 .cell execution_count=4}\n``` {.python .cell-code}\n# Create a directed graph\nDG = nx.DiGraph()\nDG.add_edges_from([(1,2), (1,3), (2, 3), (3, 4), (3, 5)])\npos = {\n    1: [0, 0],\n    2: [-1, -1],\n    3: [1, -1],\n    4: [1, 0],\n    5: [2, 0]\n}\n\n# Plot the directed graph\nplt.figure(figsize=(6, 4))\nnx.draw_networkx(DG,\n                 node_size=300,\n                 edge_color='k',\n                 node_color='lightblue',\n                 pos=pos,\n                 with_labels=True,\n                 arrowsize=25,\n                 alpha=1, linewidths=2)\nplt.title('Directed Graph', size=16)\nplt.axis('off')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-revealjs/cell-4-output-1.png){width=466 height=339 fig-align='center'}\n:::\n:::\n\n\n## Paths\n\nA __path__ in a graph from node $u$ to node $v$ is a sequence of edges that starts at $u$ and ends at $v$. Paths exist in both undirected and directed graphs.\n\nIn a directed graph, all of the edges in a path need to be oriented head-to-tail.\n\nIf there is a path from $u$ to $v$, we say that $v$ is __reachable__ from $u$.\n\n---\n\nA path from node 1 to node 5 is illustrated in red.\n\n::: {#ad4156b5 .cell execution_count=5}\n``` {.python .cell-code}\n# Create a directed graph\nDG = nx.DiGraph()\nDG.add_edges_from([(1, 2), (1, 3), (2, 3), (3, 4), (3, 5)])\n\n# Define positions for the nodes\npos = {\n    1: [0, 0],\n    2: [-1, -1],\n    3: [1, -1],\n    4: [1, 0],\n    5: [2, 0]\n}\n\n# Define the path from node 1 to node 5\npath_edges = [(1, 3), (3, 5)]\n\n# Plot the directed graph\nplt.figure(figsize=(6, 4))\nnx.draw_networkx(DG,\n                 node_size=300,\n                 edge_color='k',\n                 node_color='lightblue',\n                 pos=pos,\n                 with_labels=True,\n                 arrowsize=25,\n                 alpha=1, linewidths=2)\n\n# Highlight the path from node 1 to node 5\nnx.draw_networkx_edges(DG,\n                       pos,\n                       edgelist=path_edges,\n                       edge_color='r',\n                       width=2.5)\n\nplt.title('Directed Graph with Path from Node 1 to Node 5', size=16)\nplt.axis('off')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-revealjs/cell-5-output-1.png){width=538 height=339 fig-align='center'}\n:::\n:::\n\n\n## Degree\n\nThe __degree__ of a node is the number of edges that connect to it.\n\nIn our example undirected graph, node $3$ has degree 4.\n\n::: {#dbf75f89 .cell execution_count=6}\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-revealjs/cell-6-output-1.png){width=466 height=339 fig-align='center'}\n:::\n:::\n\n\n---\n\nIn a directed graph, we distinguish between:\n\n* __in-degree__: the number of incoming edges to the node,\n* __out-degree__: the number of outgoing edges to the node.\n\nIn our directed graph example, the in-degree of node $3$ is 2 and the out-degree is $2$.\nFor node $1$, the in-degree is $0$, and the out-degree is $2$.\n\n::: {#0ad48ef8 .cell execution_count=7}\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-revealjs/cell-7-output-1.png){width=466 height=339 fig-align='center'}\n:::\n:::\n\n\n---\n\nIn an undirected graph with $n$ nodes and $e$ edges, the average node degree is $2e/n$. Why? \n\n:::: {.fragment}\nIf you sum the degrees of all nodes, you count each edge twice (once for each endpoint). The total degree of all nodes is then $2e$. The average is then $2e/n$.\n::::\n\n:::: {.fragment}\nIn our previous example, the total degree is\n$$\n\\text{Total Degree} = 2 + 2 + 4 + 1 + 1 = 10.\n$$\n\nThe number of edges is $5$ and $2\\cdot 5 = 10$.\n::::\n\n## Neighbors\n\nThe __neighbors__ of a node are the nodes to which it is connected.\n\nIn an undirected graph, the degree of a node is the number of neighbors it has.\n\nA directed graph has both outgoing and incoming neighbors.\n\n\n## Connectivity\n\nThe first question to ask about a graph is: is it __connected__?\n\nAn undirected graph is connected, if for each pair of nodes $(u, v)$, $u$ is reachable from $v$. A directed graph is connected when its undirected version is connected.\n\n::: {#9ddbf04b .cell execution_count=8}\n``` {.python .cell-code}\nG = nx.Graph()\nG.add_edges_from([(1,2), (1,3), (2, 3)])\nG.add_node(4)\nG.add_node(5)\nDG = nx.Graph()\nDG.add_edges_from([(1,2), (3, 1), (2, 3), (3, 4), (3, 5)])\npos = {\n    1: [0, 0],\n    2: [-1, -1],\n    3: [1, -1],\n    4: [1, 0],\n    5: [2, 0]\n}\nfig = plt.figure(figsize = (10, 2.5))\nax1 = fig.add_subplot(121)\nnx.draw_networkx(G, \n                 ax = ax1,\n                 node_size=300, \n                 edge_color='k',\n                 node_color = 'lightblue', \n                 pos = pos,\n                 with_labels=True, \n                 arrowsize = 25,\n                 alpha=1, linewidths=2)\nplt.axis('off')\nplt.title('Not Connected', size = 16)\nax2 = fig.add_subplot(122)\nnx.draw_networkx(DG, \n                 ax = ax2,\n                 node_size=300, \n                 edge_color='k',\n                 node_color = 'lightcoral',\n                 pos = pos,\n                 with_labels=True, \n                 arrowsize = 25,\n                 alpha=1, linewidths=2)\nplt.title('Connected', size = 16)\nplt.axis('off')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-revealjs/cell-8-output-1.png){width=763 height=229 fig-align='center'}\n:::\n:::\n\n\nIf the graph is not connected, it may contain __connected components__.   \n\nA connected component is a subgraph that is connected. The above graph on the left has a connected subgraph.\n\n--- \n\nIn a directed graph, we can also ask if it is __strongly connected.__\n\nA directed graph is strongly connected if there is a (directed) path between any two nodes.\n\nThat is, any node is reachable from any other node.\n\nWithin a directed graph, only a subset of nodes may be strongly connected.\n\nThese are called the __strongly connected component__ (SCC).\n\n::: {#5cb5c662 .cell execution_count=9}\n``` {.python .cell-code}\nG = nx.DiGraph()\nG.add_edges_from([(1,2), (1,3), (2, 3), (3, 4), (3, 5)])\nDG = nx.DiGraph()\nDG.add_edges_from([(1,2), (3, 1), (2, 3), (3, 4), (3, 5)])\npos = {\n    1: [0, 0],\n    2: [-1, -1],\n    3: [1, -1],\n    4: [1, 0],\n    5: [2, 0]\n}\nfig = plt.figure(figsize = (12, 4))\nax1 = fig.add_subplot(121)\nnx.draw_networkx(G, \n                 ax = ax1,\n                 node_size=300, \n                 edge_color='k',\n                 node_color = 'lightblue', \n                 pos = pos,\n                 with_labels=True, \n                 arrowsize = 25,\n                 alpha=1, linewidths=2)\nplt.axis('off')\nplt.title('No SCC', size = 16)\nax2 = fig.add_subplot(122)\nnx.draw_networkx(DG, \n                 ax = ax2,\n                 node_size=300, \n                 edge_color='k',\n                 node_color = ['lightcoral', 'lightcoral', 'lightcoral', 'lightblue', 'lightblue'],\n                 pos = pos,\n                 with_labels=True, \n                 arrowsize = 25,\n                 alpha=1, linewidths=2)\nplt.title('Has a SCC', size = 16)\nplt.axis('off')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-revealjs/cell-9-output-1.png){width=912 height=339 fig-align='center'}\n:::\n:::\n\n\n# Characterizing Graphs\n\nGiven a graph, it is helpful to characterize the degrees, components, and other structures in the graph.\n\n## Comparison Case: the $G(n, p)$ Random Graph\n\nThe most common comparison is the __$G(n, p)$ random graph__. It is also called the __Erdős–Rényi__ graph, after the two mathematicians who developed and studied it.\n\nThe $G(n, p)$ random graph model is very simple\n\n* we start with a set of $n$ nodes,\n* for each pair of nodes, we connect them with probability $p$.\n\nIn this graph, the average node degree is $np$.\n\n---\n\nIn this graph, the average degree is $np = 35 \\cdot 0.15 = 5.25$\n\n::: {#c0d18ee3 .cell execution_count=10}\n``` {.python .cell-code}\nn = 35\np = 0.15\ner = nx.erdos_renyi_graph(n, p, seed = 0)\nplt.figure(figsize = (8, 5))\nnx.draw_networkx(er, node_size=45, \n                 edge_color='gray', \n                 pos = nx.spring_layout(er, seed = 1),\n                 with_labels=False, alpha=1, linewidths=2)\nplt.axis('off')\nplt.title(f'$G(n, p)$ with $n$ = {n} and $p$ = {p:0.2f}', size = 16)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-revealjs/cell-10-output-1.png){width=614 height=414 fig-align='center'}\n:::\n:::\n\n\nMost real-world graphs do __not__ match the properties of $G(n, p)$ graphs, however it is useful to have a comparison to a *random* graph.\n\n## Degree Distributions\n\nUnderstanding connectivity starts with determining the observed degrees in the graph.\n\nThis is captured in the __degree distribution__\n\n$$ \nP(D > x) = \\text{probability that a node has degree at least } x.\n$$\n\nWe typically focus our attention on large values of $x$ -- nodes that are highly connected.\n\n## Power Law Degree Distributions\n\nIt's common for a degree distribution to __approximately__ follow a power-law.\n\nThe simplest power-law distribution is called the Pareto distribution:\n\n$$ P(D > x) = k^{\\alpha} x^{-\\alpha}\\;\\;\\; k \\leq x,\\; \\;0 < \\alpha\n\\leq 2. $$\n\nIt takes on values in the range $[k, \\infty]$. \n\n---\n\nHere is an example Pareto probability density function.\n\n::: {#572dc67f .cell execution_count=11}\n``` {.python .cell-code}\nfrom scipy.stats import pareto\nalpha = 1.3\nx = np.linspace(pareto.ppf(0.005,alpha), pareto.ppf(0.995,alpha), 100)\nplt.figure(figsize = (8, 6))\nplt.plot(x, pareto.pdf(x,alpha),'b-', lw = 5, alpha = 0.6, label='pareto pdf')\nplt.title(r'Pareto PDF.  $\\alpha$ = {}'.format(alpha), size=16)\nplt.xlabel('$x$', size=14)\nplt.ylabel('$p(x)$', size=14)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-revealjs/cell-11-output-1.png){width=670 height=533 fig-align='center'}\n:::\n:::\n\n\n---\n\nIn a distribution like this, almost all values are very small. However, there is a non-negligible fraction of values that are __very__ large.\n\nA tongue-in-cheek way to refer to this property is\n\n- grains of sand mixed with a few boulders, or\n- elephants and mice.\n\nWhat does this mean for node degree?\n\nIt means that \n\n* most nodes have __few neighbors,__ but\n* an important small subset of nodes have __many, many neighbors.__\n\n---\n\nTo capture such high-variable degree distributions, a common strategy is to plot them on __log-log__ axes.\n\nOn log-log axes, a Pareto distribution appears as a straight line,\n\n::: {#baafa0e3 .cell execution_count=12}\n``` {.python .cell-code}\nfrom scipy.stats import pareto\nalpha = 1.3\nplt.figure(figsize = (7, 5))\nx = np.linspace(pareto.ppf(0.005,alpha), pareto.ppf(0.995,alpha), 100)\nplt.plot(np.log10(x), np.log10(pareto.pdf(x,alpha)),'b-', lw = 5, alpha = 0.6, label='pareto pdf')\nplt.title(r'Pareto PDF.  $\\alpha$ = {}'.format(alpha), size=16)\nplt.xlabel('$\\log_{10}(x)$', size=14)\nplt.ylabel('$\\log_{10}(p(x))$', size=14)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-revealjs/cell-12-output-1.png){width=607 height=461 fig-align='center'}\n:::\n:::\n\n\n## Power Law Degree Distributions are Ubiquitous\n\n![](figs/L21-newman-powerlaws.png){fig-align=center width=40%}\n\n---\n\n> The networks shown are: (a) the collaboration network of mathematicians [182]; (b) citations between 1981 and 1997 to all papers cataloged by the Institute for Scientific Information [351]; (c) a 300 million vertex subset of the World Wide Web, circa 1999 [74]; (d) the Internet at the level of autonomous systems, April 1999 [86]; (e) the power grid of the western United States [416]; (f) the interaction network of proteins in the metabolism of the yeast S. Cerevisiae [212]. \n>\n> _The structure and function of complex networks,_ M. E. J. Newman\n>\n> https://arxiv.org/abs/cond-mat/0303516\n\nWe remark that $G(n, p)$ random graphs do __not__ have power-law degree distributions. \n\nTheir degree distributions have exponential tails, similar to the power grid example above. Note that the $x$-axis of the power grid example is a linear scale but the $y$-axis is a log scale.\n\n## Clustering\n\nThe next important property of a network to understand is __clustering__.  \n\nIn the context of networks, clustering refers to the tendency for groups of nodes to have higher connectivity within the group than the network-wide average.\n\nThe simplest measure of local clustering is __clustering coefficient__.\n\nThe clustering coefficient tells you if the neighbors of a node tend to be neighbors.\n\n---\n\nSpecifically, clustering coefficient measures the __probability that two of your neighbors are connected.__ \n\nThere are two ways to measure this, the first is\n\n$$\nC^{(1)} = \\frac{\\sum_i \\text{number of triangles that include node } i}{\\sum_i \\text{number of pairs of neighbors of node }i}. \n$$\n\nThis is the ratio of the mean triangle count to mean neighbor pair count.\n\nIt is the probability that a __random pair__ of neighbors are connected.\n\n---\n\nConsider the following example graph.\n\n::: {#d482b7af .cell execution_count=13}\n``` {.python .cell-code}\nG = nx.Graph()\nG.add_edges_from([(1,2), (1,3), (2, 3), (3, 4), (3, 5)])\nplt.figure(figsize = (6, 4))\nnx.draw_networkx(G, node_size=300, \n                 edge_color='k', \n                 pos = nx.spring_layout(G, seed = 1),\n                 with_labels=False, alpha=1, linewidths=2)\nplt.axis('off')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-revealjs/cell-13-output-1.png){width=466 height=315 fig-align='center'}\n:::\n:::\n\n\nThe clustering coefficient $C^{(1)} = \\frac{3}{1 + 1 + 6} = \\frac{3}{8} = 0.375.$\n\n---\n\nThe second way to measure the clustering coefficient is the mean of the ratios, i.e.,\n    \n$$ \nC^{(2)} = \\frac{1}{n} \\sum_i \\frac{\\text{number of triangles that include node } i}{\\text{number of pairs of neighbors of node }i},\n$$\n\nwhere $n$ is the total number of nodes.\n\nThis is the probability that neighbors are connected for a __random node__.\n\nIn the previous example, $C^{(2)} = \\frac{1}{5} \\left(1 + 1 + \\frac{1}{6}\\right) = \\frac{13}{30} = 0.433.$\n\n---\n\nWhat is the clustering coefficient in a $G(n, p)$ random graph?\n\nThe probability that two of your neighbors are connected is the same as the probability that __any__ two nodes are connected, i.e., $C^{(1)} = C^{(2)} = p$.\n\n## Real World Graphs \n\nIn practice, real world graphs show strong clustering.\n\nFor example, consider a social network. Your friends are much more likely to be themselves friends than two randomly chosen people.\n\n![](figs/L21-clustering-coefs.png){fig-align=center width=800px}\n\n## Clustering and Path Length: Small Worlds\n\nThe strong presence of clustering in networks leads to a question. \n\nHow long is a typical shortest path between nodes?\n    \nThe average shortest path length between nodes is one way to measure a network's *diameter*.\n\n---\n\nLet's consider a highly clustered graph.\n\n![](figs/L21-high-clustering.png){fig-align=center width=300px}\n\nIn this graph, each node has 4 neighbor. Of the 6 pairs of neighbors, 3 are connected, yielding a clustering coefficient of 0.5. This is quite high.\n\nWhat is the average shortest path between nodes?   \n\nIt seems to be around $n/8$. On average you go 1/4 of the way around the circle, in hops of 2. \n\nIn this example, the path length grows linearly with $n$. \n\nIn general, __if the number of nodes is large, the average path length is large.__\n\n---\n\nReal-world social networks are highly clustered. Based on this model, we might assume that the average path length between two people in a large social network is going to be quite large. Is this really true?\n\nIf you choose two people at random from the population of the United States, is the shortest path length between them long?\n\nIn 1967 the social psychologist Stanley Milgram set out to empirically answer this question.\n\n:::: {.columns}\n::: {.column width=\"30%\"}\n![](figs/Stanley_Milgram_Profile.jpeg){width=200px}\n:::\n::: {.column width=\"70%\"}\nMilgram picked 160 people at random in Omaha, Nebraska.  (It helped that there used to be phone books.)\n\nHe asked them to get a letter to a particular person, a stockbroker in Boston.\n\nThe rules that he set were that they could only pass the letter between friends that were known on a first-name basis.\n\nSurprisingly, 62 of the letters made it to the stockbroker!\n:::\n::::\n\nMore surprising was the fact that the __average path length was 6.2 people!__\n\n---\n\nThis statistic became famous when John Guare wrote a play called _Six Degrees of Separation_.\n\nGiven what we know about clustering in social networks, this is quite surprising. How can we explain it?\n\nThe first clue comes from another classic social science paper, called _The Stength of Weak Ties,_ by Mark Granovetter.\n\nThis is sometimes referred to as the most famous paper in sociology (with over 60,000 citations).   \n\nGranovetter interviewed people about how the found their jobs. He found that most people did not get a job through someone that was a close friend, but rather through a __distant__ acquaintance.\n\nThis suggests that an important way that information travels in a social network is via the rare connections that exist __outside__ of the local clustering of friendships.\n\n---\n\nThis was all put on an experimental basis in __another__ classic paper, by the social scientist Duncan Watts and the mathematician Steve Strogatz.\n\nIn their paper _Collective Dynamics of Small-World Networks_, Watts and Strogatz perfomed an elegant experiment.\n\nThey asked, what if we take a highly clustered network, and slightly perturb it?\n\n---\n\nSpecifically, they started with a network in which each node is connected to a fixed number of neighbors, and connections are made in a __highly clustered__ way.\n\n![](figs/L21-watts-strogatz.png){fig-align=\"center\" width=\"60%\"}\n\nThen, with probability $p$, __rewire__ each edge: change it to connect to a __random__ destination.\n\nAs $p$ varies, what happens to\n\n* the average path length $L(p)$ and\n* the clustering coefficient $C(p)$?\n\n---\n\nHere is the famous figure from that paper. Observe the log scale on the $p$ axis.\n   \n![](figs/watts-strogatz-2.png){width=\"700px\"}\n\n---\n\nWhat Watts and Strogatz showed is that __it only takes a small amount of long-range connections__ to dramatically shrink the average path length between nodes.\n\nThey showed that high clustering and short path lengths can coexist. They called networks with high clustering and short path lengths __small world networks__.\n\nThis phenomenon expresses itself repeatedly.\n\n---\n\nFor example, consider the network of movie actors: two actors are connected if they appear in the same movie.\n\nThus we have the phenomenon of the __six degrees of Kevin Bacon__.\n\n![](figs/L21-six-degrees-bacon.png){fig-align=\"center\" width=\"700px\"}\n\n---\n\nYou can try your luck at [The Oracle of Bacon](https://oracleofbacon.org/movielinks.php).\n\n:::: {.columns}\n::: {.column width=\"50%\"}\nFor example, Elvis Presley:\n\n![](figs/L21-oracle-bacon.png){fig-align=\"center\" width=\"300px\"}\n:::\n::: {.column width=\"50%\"}\nWhat's special about Kevin Bacon?\n\nNot really anything.  \n\nBecause movie co-appearance forms a small world network, most any path between two actors is a short one.\n:::\n::::\n\n\n## Implications of Small Worlds \n\nViruses spread rapidly in small worlds.  \n\nOne of the goals of pandemic lock-downs is to prevent people circulating in their local social groups. This is an attempt to eliminate the effect of long-range (weak-tie) connections.\n\nThis is the idea behind travel bans and mandatory quarantining after travel.\n\n---\n\nHere is a figure showing the effect on virus propagation of deleting most of the long-range edges from a small-world network.\nDifferent curves correspond to when the lock-down is deployed.\n\n![](figs/L21-covid-mitigation.png){fig-align=\"center\" width=\"600px\"} \n    \nFrom [_Mitigating COVID-19 on a Small-World Network_,](https://www.nature.com/articles/s41598-021-99607-z) Marvin Du, Scientific Reports Oct 2021.\n\n---\n\nAnother question concerns how *shortcuts* arise. Recall that node degree distributions typically follow a power-law.\n\nDespite most people have small acquaintance sets, a small subset of people are very highly connected.\n\n![](figs/F2.large.jpeg){fig-align=\"center\" width=\"500px\"}\n\nThese *high social capital* individuals play a big role in creating long-range, path-shortening connections in social networks.\n\n## Analyzing Graphs\n\nWe have seen different strategies to characterize a graph. To perform further analysis we will employ the following strategies:\n\n* visualize the network in a way that communicates as much insight as possible, and\n* compute important metrics of the network.\n\n## Visualizing Networks\n\nAs an example, we'll consider the following network, which records American football games between NCAA Division IA colleges in the Fall of 2000 (available [here](http://www-personal.umich.edu/~mejn/netdata/)). \n\nEach vertex represents a football team, which belongs to a specific conference (Big Ten, Conference USA, Pac-10, etc.). \n\nAn edge between two vertices $v_1$ and $v_2$ means that the two teams played each other. The weight of the edge ($v_1$, $v_2$) is equal to the number of times they played each other.\n\nThis data comes from  M. Girvan and M. E. J. Newman,\n_Community structure in social and biological networks,_\nProc. Natl. Acad. Sci. USA 99, 7821-7826 (2002).\n\n::: {#916342c6 .cell execution_count=14}\n``` {.python .cell-code code-fold=\"false\"}\nfootball = nx.readwrite.gml.read_gml('data/football.gml')\n\nprint(f'The football network has {len(football.nodes())} nodes and {len(football.edges())} edges')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe football network has 115 nodes and 613 edges\n```\n:::\n:::\n\n\n---\n\nTo get a sense of what is unusual here, we can compare this network to a $G(n, p)$ random network with the same number of nodes and edges.\n\n::: {#68eee3b7 .cell execution_count=15}\n``` {.python .cell-code code-fold=\"false\"}\nn = len(football.nodes())\ne = len(football.edges())\np = e / ((n * (n-1))/2)\nF_random = nx.erdos_renyi_graph(n, p, seed = 0)\n```\n:::\n\n\n---\n\nOne way to visualize is to use a circular layout, which keeps all the edges in the interior. \n\nThis can make things easier to see sometimes.\n\n::: {#9f2db09b .cell execution_count=16}\n``` {.python .cell-code}\nplt.figure(figsize = (18, 8))\nax1 = plt.subplot(121)\nnx.draw_networkx(football, ax = ax1,\n                 node_size=35, \n                 edge_color='gray', \n                 pos = nx.circular_layout(football),\n                 with_labels=False, alpha=.8, linewidths=2)\nplt.axis('off')\nplt.title('Title 1 Football -- Circular Layout', size = 16)\nax2 = plt.subplot(122)\nnx.draw_networkx(F_random, ax = ax2,\n                 node_size=35, \n                 edge_color='gray', \n                 pos = nx.circular_layout(F_random),\n                 with_labels=False, alpha=.8, linewidths=2)\nplt.axis('off')\nplt.title('Same Density Random -- Circular Layout', size = 16)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-revealjs/cell-16-output-1.png){width=1358 height=635}\n:::\n:::\n\n\n---\n\nThere is some non-random structure here, but it's not clear exactly what it is. To better investigate this network we will use a more informative layout.\n\nThe standard `networkx` routine uses what is called a *spring* layout. \n\nHere is how the *spring* layout works.\n\n* Each edge has a `weight` parameter (could be 1 for all edges).  \n* The layout routine fixes \n    * a spring of length = 1/`weight` between the nodes, \n    * a repulsive force between each pair of nodes,\n    * and then lets the set of all forces reach its minimum energy state.  \n\nThis is a kind of minimal distortion in a least-squares sense.\n\n## Spring Layout\n\n::: {#9b2a6248 .cell execution_count=17}\n``` {.python .cell-code}\nplt.figure(figsize = (18, 8))\nax1 = plt.subplot(121)\nnx.draw_networkx(football, ax = ax1,\n                 node_size=35, \n                 edge_color='gray', \n                 pos = nx.spring_layout(football, seed = 0),\n                 with_labels=False, alpha=.8, linewidths=2)\nplt.axis('off')\nplt.title('Title 1 Football -- Spring Layout', size = 16)\nax2 = plt.subplot(122)\nnx.draw_networkx(F_random, ax = ax2,\n                 node_size=35, \n                 edge_color='gray', \n                 pos = nx.spring_layout(F_random, seed = 0),\n                 with_labels=False, alpha=.8, linewidths=2)\nplt.axis('off')\nplt.title('Same Density Random -- Spring Layout', size = 16)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-revealjs/cell-17-output-1.png){width=1358 height=635 fig-align='center'}\n:::\n:::\n\n\nNotice how the spring layout tends to bring clusters of densely connected nodes close to each other.\n\n## Spectral Layout\n\nFinally, we can try the spectral layout. We will define the spectral layout in the next lecture.\n\n::: {#33fb9ca5 .cell execution_count=18}\n``` {.python .cell-code}\nplt.figure(figsize = (18, 8))\nax1 = plt.subplot(121)\nnx.draw_networkx(football, ax = ax1,\n                 node_size=35, \n                 edge_color='gray', \n                 pos = nx.spectral_layout(football),\n                 with_labels=False, alpha=.8, linewidths=2)\nplt.axis('off')\nplt.title('Title 1 Football -- Spectral Layout', size = 16)\nax2 = plt.subplot(122)\nnx.draw_networkx(F_random, ax = ax2,\n                 node_size=35, \n                 edge_color='gray', \n                 pos = nx.spectral_layout(F_random),\n                 with_labels=False, alpha=.8, linewidths=2)\nplt.axis('off')\nplt.title('Same Density Random -- Spectral Layout', size = 16)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-revealjs/cell-18-output-1.png){width=1358 height=635 fig-align='center'}\n:::\n:::\n\n\n---\n\nWith the spectral layout, we can start to understand the structure of the network.\n\nWe see clusters of teams that correspond to conferences, and understand that there are not too many high-degree nodes.\n\n::: {#8047594d .cell execution_count=19}\n``` {.python .cell-code}\nplt.figure(figsize = (5, 7))\nnx.draw_networkx(football,\n                 node_size=35, \n                 edge_color='gray', \n                 pos = nx.spectral_layout(football),\n                 with_labels=False, alpha=.8, linewidths=2)\nplt.axis('off')\nplt.title('Title 1 Football -- Spectral Layout', size = 16)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-revealjs/cell-19-output-1.png){width=391 height=561 fig-align='center'}\n:::\n:::\n\n\n## Metrics\n\nAnother way to understand network structured data is to look at important metrics.\n\nFor example, we can start with the __clustering coefficient:\n\n::: {#5d2aa831 .cell execution_count=20}\n``` {.python .cell-code}\nclustering_coefficient = nx.average_clustering(football)\nprint(f'The clustering coefficient of the Football network is {clustering_coefficient:0.3f}')\ncc_random = nx.average_clustering(F_random)\nprint(f'The clustering coefficient for the equivalent random network is {cc_random:0.3f}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe clustering coefficient of the Football network is 0.403\nThe clustering coefficient for the equivalent random network is 0.088\n```\n:::\n:::\n\n\nAnother useful metric is the diameter.\n\n::: {#d9a75220 .cell execution_count=21}\n``` {.python .cell-code}\nprint(f'The diameter of the Football network is {nx.diameter(football)}' +\n      f' and the average shortest path length is {nx.average_shortest_path_length(football):0.3f}')\nprint(f'The diameter of the equivalent random network is {nx.diameter(F_random)}' +\n      f' and the average shortest path length is {nx.average_shortest_path_length(F_random):0.3f}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe diameter of the Football network is 4 and the average shortest path length is 2.508\nThe diameter of the equivalent random network is 4 and the average shortest path length is 2.215\n```\n:::\n:::\n\n\n---\n\nThe next property we can look at is the __degree distribution__.\n\n::: {#be93fdda .cell execution_count=22}\n``` {.python .cell-code}\ndegree_freq = nx.degree_histogram(football)\ndegrees = np.array(range(len(degree_freq)))\n```\n:::\n\n\n::: {#1a2aafd6 .cell execution_count=23}\n``` {.python .cell-code}\nplt.figure(figsize = (8, 6))\nplt.bar(degrees, degree_freq)\nplt.xlabel('Degree', size = 14)\nplt.ylabel('Number of Nodes', size = 14)\nplt.title('Degree Distribution of Football Network', size = 16)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-revealjs/cell-23-output-1.png){width=664 height=533 fig-align='center'}\n:::\n:::\n\n\n---\n\nTo get a sense of what is unusual here, we can again compare this to the equivalent random network.\n\n::: {#883bc206 .cell execution_count=24}\n``` {.python .cell-code}\nrand_degree_freq = nx.degree_histogram(F_random)\nrand_degrees = range(len(rand_degree_freq))\nplt.figure(figsize = (8, 6))\nplt.bar(rand_degrees, rand_degree_freq, 0.425, label = 'Random')\nplt.bar(degrees+0.5, degree_freq, 0.425, label = 'Actual')\nplt.xlabel('Degree', size = 14)\nplt.ylabel('Number of Nodes', size = 14)\nplt.legend(loc = 'best', fontsize = 14)\nplt.title('Degree Distribution of Football Network\\nCompared to Random', size = 16)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](21-Networks-I_files/figure-revealjs/cell-24-output-1.png){width=674 height=557 fig-align='center'}\n:::\n:::\n\n\nWe can see the evidence of scheduling of games in this distribution: a much larger number of teams plays 11 games than would occur by chance.\n\n\n## Recap\n\nWe introduced\n\n- Networks\n    - directed, undirected graphs,\n    - degree, paths, neighbors, connectivity\n- $G(n, p)$ random graph\n- Degree distributions\n- Cluster coefficients\n- Graph metrics\n- Visualizing graphs, spring and spectral layouts\n\n",
    "supporting": [
      "21-Networks-I_files"
    ],
    "filters": [],
    "includes": {}
  }
}