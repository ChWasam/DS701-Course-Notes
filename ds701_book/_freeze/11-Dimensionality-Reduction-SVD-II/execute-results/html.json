{
  "hash": "03472e32be2169ac24d4addbd790382b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Dimensionality Reduction - PCA + t-SNE\njupyter: python3\nbibliography: references.bib\nnocite: |\n  @novembre2008genes, @strang2022introduction\n---\n\n\n[![](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/tools4ds/DS701-Course-Notes/blob/main/ds701_book/jupyter_notebooks/11-Dimensionality-Reduction-SVD-II.ipynb)\n\nWe previously learned how to use the SVD as a tool for constructing low-rank matrices.\n\nWe now consider it as a tool for transforming (i.e., reducing the dimension of) our data. \n\n## Overview\n\nCollected data is often high-dimensional. The high-dimensionality of, or the large number of features in a dataset is challenging to work with. \n\n![](figs/elephant_perspective.png){fig-align=\"center\" width=50%}\n\n## High-Dimensional Challenges\n\nWe have seen some of these challenges already, in particular:\n\n:::: {.incremental}\n- the curse of dimensionality, where data points become sparse in higher dimensions and distance metrics have less meaning,\n- overfitting, where high-dimensional data can lead models becoming overly complex and fitting to noise in the data as opposed to the actual signal,\n- computational complexity, high-dimensional data requires more computing power and memory,\n- visualization, where high-dimensional data makes understanding and interpreting the data difficult our data.\n::::\n\n--- \n\nHow can we reduce the dimension of our data but still preserve the most important information in our dataset?\n\n:::: {.fragment}\nWe consider two techniques:\n\n:::: {.incremental}\n- Principle Component Analysis (PCA)\n- t-distributed stochastic neighbor embedding (t-SNE)\n::::\n::::\n\n:::: {.fragment}\nWe will demonstrate the relationship between PCA and the SVD.\n\nt-SNE is an alternative nonlinear method for dimensionality reduction.\n::::\n\n# PCA \n\n## Dimensionality Reduction \n\nInput: $\\mathbf{x}_1,\\ldots, \\mathbf{x}_m$ with  $\\mathbf{x}_i \\in \\mathbb{R}^n \\: \\: \\forall \\: i \\in \\{1, \\ldots, n\\}.$\n\nOutput: $\\mathbf{y}_1,\\dots, \\mathbf{y}_m$  with  $\\mathbf{y}_i \\in \\mathbb{R}^d \\: \\: \\forall \\: i \\in \\{1, \\dots, n\\}$. \n\nThe goal is to compute the new data points $\\mathbf{y}_i$ such that <font color=\"red\"> $d << n$ </font> while still preserving the most information contained in the data points $\\mathbf{x}_i$.\n\n$$\nX_0 = \n\\begin{bmatrix} \nx_{11} & x_{12} & \\dots & x_{1n} \\\\\nx_{21} & x_{22} & \\dots & x_{2n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nx_{m1} & x_{m2} & \\dots & x_{mn} \n\\end{bmatrix} \\:\n\\xrightarrow[\\text{PCA}]{} \\:\nY = \\begin{bmatrix} \ny_{11} & y_{12} & \\dots & y_{1d} \\\\\ny_{21} & y_{22} & \\dots & y_{2d} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\ny_{m1} & y_{m2} & \\dots & y_{md} \n\\end{bmatrix}\n$$\n\n## PCA Application: Genes Mirror Geography\n\nWe consider a dataset from @novembre2008genes. The authors collected DNA data called SNPs (single nucleotide polymorphism) from 3000 individuals in Europe. \n\nSNPs describe the changes in DNA from a common base pair (A,T,C,G). A value of 0 means no changes to the base pair, a value of 1 means 1 change to the base pair, and a value of 2 means both base pairs change.\n\nThe data for each individual consisted of approximately 500k SNPs.\n\n---\n\n\nThe authors performed PCA and plotted 1387 of the individuals in the reduced dimensions.\n\n![Image Credit @novembre2008genes](figs/PCA_genes_Europe.png)\n\n---\n\nKey observations:\n\n:::: {.incremental}\n- the first principal components of the data almost reproduce the map of Europe\n- SNPs are similar geographically\n- DNA of an individual reveals their birthplace within a few hundred kilometers\n::::\n\n:::: {.fragment}\nWould a similar study in the USA be effective?\n::::\n\n## PCA Steps\n\nInput: $X_0\\in\\mathbb{R}^{m\\times n}$\n\nOutput: $Y\\in\\mathbb{R}^{m\\times d}$ with $d << n$.\n\n1. Center the data (subtract the mean across rows): $X_0 \\rightarrow X$.\n\n    Example:\n    $$\n    X_0 = \n    \\begin{bmatrix}\n    90 & 60 & 60\\\\\n    80 & 60 & 70 \\end{bmatrix}\n    $$\n\n    The mean across rows is:\n    $$\n    \\boldsymbol{\\mu} = \\begin{bmatrix} 85 & 60 & 65 \\end{bmatrix}\n    $$\n\n---\n\n2. Find the direction of the largest variance. This is the first principal component (PC1).\n\n3. From the $d-1$ directions orthogonal to PC1, find the one with the largest variance. This is the second principal component (PC2).\n\n4. Repeat step 3 until you have accounted for all $d$ directions.\n\n5. Project the data into the direction of the PCs.\n\n## Least Squares Interpretation\n\nCentered data often clusters along a line (or other low-dimensional subspace of $\\mathbb{R}^{n}$).\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n![](figs/PCA_variance.png)\nThe sum of **variances** (squared distances to the mean) of the projected points is a **maximum**.\n:::\n::: {.column width=\"50%\"}\n![](figs/PCA_residual.png)\nThe sum of **residuals** (squared distances from the points to the line) is a **minimum**.\n:::\n::::\n\n:::: {.fragment}\nWhat is the statistical entity that measures the variability in the data?\n::::\n\n## Covariance Matrix\n\nLet $X\\in\\mathbb{R}^{m\\times n}$ contained the centered data. Recall that the sample covariance matrix is defined by\n\n$$\nS = \\frac{1}{m-1}X^{T}X\n$$\n\nExample:\nExample:     \n$$\nX = \\begin{bmatrix}\n5 & 0 & -5\\\\\n-5 & 0 & 5 \\end{bmatrix} \n$$\n\n$$ \nS =  \n\\begin{bmatrix}\n5 & -5\\\\\n0 & 0\\\\\n-5 & 5 \\end{bmatrix} \n\\begin{bmatrix}\n5 & 0 & -5\\\\\n-5 & 0 & 5 \\end{bmatrix}\n=\n\\begin{bmatrix}\n50 & 0 & -50\\\\\n0 & 0 & 0\\\\\n-50 & 0 & 50 \\end{bmatrix}\n$$\n\n## Spectral Decomposition\n\nObserve that the matrix $S$ is symmetric, i.e., $S = S^{T}.$\n\nEvery real symmetric matrix $S$ has the factorization $V\\Lambda V^{T}$, where $\\Lambda$ is a diagonal matrix that contains the eigenvalues of S and teh columns of $V$ are orthogonal eigenvectors of $S$.\n\nYou can refresh your memory about this in the [Linear Algebra Refresher](04-Linear-Algebra-Refresher.qmd).\n\n---\n\nThe covariance matrix $S \\in \\mathbb{R}^{n\\times n}$ can be written as $S = V\\Lambda V^T$ where\n\n$$\n\\Lambda = \n\\begin{bmatrix}\n\\lambda_1                                   \\\\\n& \\lambda_2             &   & \\text{\\Large0}\\\\\n&               & \\ddots                \\\\\n& \\text{\\Large0} &   & \\lambda_{n-1}            \\\\\n&               &   &   & \\lambda_n\n\\end{bmatrix}\n$$\nwith $\\lambda_1 \\geq \\lambda_2 \\geq \\dots \\geq \\lambda_{n-1} \\geq \\lambda_n$, and\n$$\nV = \\begin{bmatrix} \n\\bigg| & \\bigg| &  & \\bigg| & \\bigg| \\\\\n\\mathbf{v}_1   & \\mathbf{v}_2  & \\dots & \\mathbf{v}_{n-1}   & \\mathbf{v}_n  \\\\\n\\bigg| & \\bigg| & & \\bigg| & \\bigg|\n\\end{bmatrix}\n $$ \n \nwith $S\\mathbf{v}_i = \\lambda_i \\mathbf{v}_i$ and $\\mathbf{v}_i \\perp \\mathbf{v}_j$ for $i\\neq j$.\n\n\n## Essentials of PCA\n\n- The columns of $V$ are the principal directions (or components).\n- The principal components are the projection of the data into principal directions: $XV$.\n- The total variance $T$ in the data is the sum of all eigenvalues: $T = \\lambda_1 + \\lambda_2 + \\dots + \\lambda_n.$\n- The first eigenvector $\\mathbf{v}_1$ points in the most significant direction of the data. This direction explains the largest fraction $\\lambda_1/T$ of the total variance.\n- The second eigenvector $\\mathbf{v}_2$ accounts for a smaller fraction $\\lambda_2/T$.\n\n## Case Study: Weight and Height\n\nLet's consider some randomly generated data consisting of 2 features, height and weight.\n\n::: {#f3e57e6a .cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nrng = np.random.default_rng(seed=42)\n\nheight = rng.normal(loc=173, scale=6.35, size = 100)\nweight = rng.normal(loc=90, scale=10, size = 100)\n\nX0 = np.stack((height, weight), axis=-1)\n\nX = X0-X0.mean(axis=0)\n\nplt.scatter(X[:, 0], X[:, 1])\nplt.title(\"Height vs. Weight mean centered\")\nplt.xlabel(\"Height in cm\")\nplt.ylabel(\"Weight in kg\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](11-Dimensionality-Reduction-SVD-II_files/figure-revealjs/cell-2-output-1.png){width=822 height=449 fig-align='center'}\n:::\n:::\n\n\n---\n\nLet's do PCA and plot the principle components over our dataset.\n\n::: {#42a826db .cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.decomposition import PCA\n\npca = PCA(n_components=2)\nprincipal_components = pca.fit_transform(X)\n\nplt.scatter(X[:, 0], X[:, 1], label='Original Data')\norigin = np.array([0, 0])\nfor i, component in enumerate(pca.components_):\n    plt.arrow(origin[0], origin[1], 5*component[0], 20*component[1], \n              color=['#D55E00', '#009E73'][i], width=0.2, head_width=0.35, label=f'PC{i+1}')\nplt.legend()\nplt.title(\"Height vs. Weight mean centered\")\nplt.xlabel(\"Height in cm\")\nplt.ylabel(\"Weight in kg\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](11-Dimensionality-Reduction-SVD-II_files/figure-revealjs/cell-3-output-1.png){width=822 height=449 fig-align='center'}\n:::\n:::\n\n\n---\n\nWe can also plot the data in our transformed space.\n\n::: {#85c9fd15 .cell execution_count=4}\n``` {.python .cell-code}\nplt.scatter(principal_components[:, 0], principal_components[:, 1], color=\"#CC79A7\")\nplt.title(\"Transformed Height and Weight Data\")\nplt.xlabel(\"PC1\")\nplt.ylabel(\"PC2\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](11-Dimensionality-Reduction-SVD-II_files/figure-revealjs/cell-4-output-1.png){width=819 height=449 fig-align='center'}\n:::\n:::\n\n\n## Case Study: Digits\n\nLet's consider another example using the MNIST dataset.\n\n::: {#9d7340a5 .cell execution_count=5}\n``` {.python .cell-code}\nfrom sklearn import datasets\ndigits = datasets.load_digits()\n\nplt.figure(figsize=(8, 8),)\nfor i in range(8):\n    plt.subplot(2, 4, i + 1)\n    plt.imshow(digits.images[i], cmap='gray_r')\n    plt.axis('off')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](11-Dimensionality-Reduction-SVD-II_files/figure-revealjs/cell-5-output-1.png){width=758 height=500 fig-align='center'}\n:::\n:::\n\n\n---\n\nWe first vectorize each digit and perform PCA on the 64-D representation of the digits.\n\nWe can plot the explained variance ratio and the total explained variance ratio.\n\n::: {#f1fa025f .cell execution_count=6}\n``` {.python .cell-code}\nfrom sklearn.decomposition import PCA\n\nX = digits.data\ny = digits.target\n\npca = PCA()\nX_pca = pca.fit_transform(X)\n\n# Create subplots\nfig, axs = plt.subplots(2, 1, figsize=(6, 5))\n\n# Scree plot (explained variance ratio)\naxs[0].plot(np.arange(1, len(pca.explained_variance_ratio_) + 1), pca.explained_variance_ratio_, marker='o', linestyle='--')\naxs[0].set_title('Scree Plot')\naxs[0].set_xlabel('Principal Component')\naxs[0].set_ylabel('Explained Variance Ratio')\naxs[0].grid(True)\n\n# Cumulative explained variance plot\naxs[1].plot(np.arange(1, len(pca.explained_variance_ratio_) + 1), np.cumsum(pca.explained_variance_ratio_), marker='o', linestyle='--')\naxs[1].set_title('Cumulative Explained Variance Plot')\naxs[1].set_xlabel('Principal Component')\naxs[1].set_ylabel('Cumulative Explained Variance')\naxs[1].grid(True)\n\n# Adjust layout\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](11-Dimensionality-Reduction-SVD-II_files/figure-revealjs/cell-6-output-1.png){width=566 height=470 fig-align='center'}\n:::\n:::\n\n\n---\n\nLet's plot the data in the first 2 principal component directions. We'll use the digit labels to color each digit in the reduced space.\n\n::: {#462aa3c5 .cell execution_count=7}\n``` {.python .cell-code}\nplt.figure(figsize=(7, 7))\nscatter = plt.scatter(X_pca[:, 0], X_pca[:, 1], c=y, cmap='tab20', edgecolor='k', s=50)\nplt.title('Digits in PC1 and PC2 Space')\nplt.xlabel('Principal Component 1')\nplt.ylabel('Principal Component 2')\n\n# Create a legend with discrete labels\nlegend_labels = np.unique(y)\nhandles = [plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=plt.cm.tab20(i / 9), markersize=10) for i in legend_labels]\nplt.legend(handles, legend_labels, title=\"Digit Label\", loc=\"best\")\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](11-Dimensionality-Reduction-SVD-II_files/figure-revealjs/cell-7-output-1.png){width=596 height=597 fig-align='center'}\n:::\n:::\n\n\n---\n\nWe observe the following in our plot of the digits in the first two principal components:\n\n- There is a decent clustering of some of our digits, in particular 0, 2, 3, 4, and 6.\n- The numbers 0 and 6 seem to be relatively close to each other in this space.\n- There is not a very clear separation of the number 5 from some of the other points..\n\n\n## To scale or not to scale\n\nConsider a situation where we have age (years) and height (feet) data for 4 people.\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n| Person | Age [years] | Height [feet] |\n|--------|-------------|---------------|\n| A      | 25          | 6.232         |\n| B      | 30          | 6.232         |\n| C      | 25          | 5.248         |\n| D      | 30          | 5.248         |\n\n:::\n::: {.column width=\"50%\"}\n![](figs/Scaling_feet.png)\n:::\n::::\n\n---\n\nWhat if the height is in cm?\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n| Person | Age [years] | Height [cm] |\n|--------|-------------|-------------|\n| A      | 25          | 189.95      |\n| B      | 30          | 189.95      |\n| C      | 25          | 159.96      |\n| D      | 30          | 159.96      |\n\n:::\n::: {.column width=\"50%\"}\n![](figs/Scaling_cm.png)\n:::\n::::\n\n---\n\nLet's standardize our data.\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n| Person | Age [years] | Height [cm] |\n|--------|-------------|-------------|\n| A      | -1          | 1           |\n| B      | 1           | 1           |\n| C      | -1          | -1          |\n| D      | 1           | -1          |\n\n:::\n::: {.column width=\"50%\"}\n![](figs/Scaling.png)\n:::\n::::\n\n--- \n\nWhat quantity is represented by $\\frac{Cov(X, Y)}{\\sigma_X\\sigma_Y}$, where $X$ and $Y$ represent the random variables associated to sampling a person with that Age and Height?\n\n:::: {.fragment}\nThis is the correlation matrix. When you standardize your data you are no longer working with the covariance matrix but the correlation matrix.\n::::\n\n## Relationship to the SVD\n\nRecall that the SVD of a mean-centered data matrix $X\\in\\mathbb{R}^{m\\times n}$ ($m>n$) is\n\n$$\nX = U\\Sigma V^T.\n$$\n\n::: {#7f5b863e .cell execution_count=8}\n\n::: {.cell-output .cell-output-display}\n![](11-Dimensionality-Reduction-SVD-II_files/figure-revealjs/cell-8-output-1.png){width=763 height=389 fig-align='center'}\n:::\n:::\n\n\n---\n\nHow can we relate this to what we learned in PCA?\n\nIn PCA, we computed an eigen-decomposition of the covariance matrix, i.e., $S=V\\Lambda V^{T}$.\n\nConsider the following computation using the SVD of $X$\n\n$$\n\\begin{align*}\nX^{T}X\n= \n(U\\Sigma V^T)^{T}(U\\Sigma V^T)\n=\nV\\Sigma U^TU \\Sigma V^{T}\n= \nV\\Sigma^{2}V^T\n\\end{align*}\n$$\n\nWe see that eigenvalues $\\lambda_i$ of the matrix $S$ are the squares $\\sigma_{i}^{2}$ of the singular values $\\Sigma$ (scaled by $\\frac{1}{n-1}$).\n\n\n---\n\nIn practice, PCA is done by computing the SVD of your data matrix as opposed to forming the covariance matrix and computing the eigenvalues. \n\nYou can then obtain the principal components from the right singular vectors $V$. The eigenvalues are obtained from squaring the entries of $\\Sigma$ and scaling them by $\\frac{1}{n-1}$\n\nThe reason to compute PCA this way is\n\n:::: {.incremental}\n- **Numerical Stability**: SVD is a numerically stable method, which means it can handle datasets with high precision and avoid issues related to floating-point arithmetic errors.\n\n- **Efficiency**: SVD is computationally efficient, especially for large datasets. Many optimized algorithms and libraries (like those in NumPy and scikit-learn) leverage SVD for fast computations.\n\n- **Handling Non-Square Matrices**: SVD can be applied directly to non-square matrices, which is useful since the data matrix in PCA is often not square. This flexibility makes SVD a versatile tool for dimensionality reduction.\n\n- **Direct Computation of Principal Components**: SVD directly provides the principal components (right singular vectors) and the singular values, which are related to the explained variance. This makes the process straightforward and avoids the need to compute the covariance matrix explicitly.\n\n::: {.content-visible when-profile=\"web\"}\n- **Robustness to Data Scaling**: SVD is less sensitive to the scaling of data compared to other methods. This robustness ensures that the principal components are accurately computed regardless of the data's scale.\n\n- **Memory Efficiency**: For large datasets, SVD can be more memory-efficient. Techniques like truncated SVD can be used to compute only the top principal components, reducing memory usage.\n\n- **Versatility**: SVD is a fundamental linear algebra technique used in various applications beyond PCA, such as signal processing, image compression, and solving linear systems. This versatility makes it a well-studied and widely implemented method.\n:::\n::::\n\n## Pros and Cons\n\nHere are some advantages (left column) and disadvantages (right column) of PCA.\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n**Advantages**\n\n+ Allows for visualizations\n+ Removes redundant variables\n+ Prevents overfitting\n+ Speeds up other ML algorithms\n:::\n::: {.column width=\"50%\"}\n**Disadvantages**\n- reduces interpretability\n- can result in information loss\n- can be less effective than non-linear methods\n:::\n::::\n\n# t-SNE\n\n## What is t-SNE?\n\n- t-SNE stands for **t-Distributed Stochastic Neighbor Embedding**.\n- It is a **non-linear dimensionality reduction technique**.\n- Primarily used for **visualizing high-dimensional data** in 2 or 3 dimensions.\n- Developed by Laurens van der Maaten and Geoffrey Hinton in 2008.\n\n\n## How t-SNE Works\n\n- t-SNE converts high-dimensional Euclidean distances into **conditional probabilities**.\n- It aims to preserve the **local structure** of the data.\n- Uses a **heavy-tailed Student-t distribution** in the low-dimensional space to prevent crowding. This is where the $t$ in $t$-SNE comes from.\n\n\nWe will describe how this process works.\n\n\n## Step 1: Compute Pairwise Similarities\n\n- Calculate pairwise similarities between points in the high-dimensional space.\n- Use a Gaussian distribution to convert distances into probabilities.\n- The similarity $p_{ij}$ between points $i$ and $j$ is given by:\n  $$\n  p_{j\\vert i} = \\frac{\\exp(-\\|x_i - x_j\\|^2 / 2\\sigma_i^2)}{\\sum_{k \\neq i} \\exp(-\\|x_i - x_k\\|^2 / 2\\sigma_i^2)}.\n  $$\n - The $p_{j\\vert i}$ value represents the conditional probability that point $x_i$ would choose $x_j$ as its neighbor. \n - Note that $p_{i\\vert i} = 0$.\n - The t-SNE method uses the quantities $p_{ij} = \\frac{p_{j\\vert i} + p_{i\\vert j}}{2d}$ where $d$ is the dimension of the point. This is because the probabilities $p_{j\\vert i}$ and $p_{i\\vert j}$ are different.\n\n## Visualizing the Pairwise Similarities\n\nThe Gaussian distribution is centered at point $x_i$ and the points $x_j$ that are further away have less probability of being chosen as neighbor.\n\n::: {#6076990c .cell execution_count=9}\n``` {.python .cell-code}\nmean = 0\nstd_dev = 1\nx = np.linspace(-5, 5, 1000)\ny = (1/(std_dev * np.sqrt(2 * np.pi))) * np.exp(-0.5 * ((x - mean) / std_dev)**2)\n\n# Points on the x-axis\npoints_x = [0, 1, 4, 4.5]\npoints_y = [0, 0, 0, 0]\ncolors = ['#009E73', '#009E73', '#CC79A7', '#CC79A7']\n\n# Create the plot\nplt.plot(x, y, label='Gaussian Distribution')\nplt.scatter(points_x, points_y, color=colors, zorder=5)\n\n# Add labels and title\nplt.xlabel('X-axis')\nplt.ylabel('Probability Density')\nplt.title('Gaussian Distribution with Individual Points')\nplt.legend()\n\n# Show the plot\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](11-Dimensionality-Reduction-SVD-II_files/figure-revealjs/cell-9-output-1.png){width=821 height=449 fig-align='center'}\n:::\n:::\n\n\n## Choosing $\\sigma$\n\nHow do we determine the variance for the Gaussian?\n\n- The variance is determined by a hyperparameter called the **perplexity**.\n- As a result the perplexity controls the effective number of neighbors. \n- A high perplexity means more neighbors for each point. A low perplexity means less neighbors are considered for each point.\n- The perplexity is defined as $\\operatorname{Perp}(P_i) = 2^{H(P_i)}$, where $H(P_i)$ is the entropy of $P_i$. $P_i$ is the probability distribution induced by $\\sigma_i$.\n- The entropy $H(P_i) = -\\sum_j p_{j\\vert i} \\log_2{(p_{j\\vert i})}$.\n- The value for $\\sigma_i$ is computed to produce a distribution $P_i$ which equals the chosen value of the perplexity. \n\nThe perplexity commonly ranges  between 5 and 50.\n\n\n## Step 2: Define Low-Dimensional Map\n\n- Initialize points randomly in the low-dimensional space.\n- Define a similar probability distribution using a Student-t distribution:\n  $$\n  q_{ij} = \\frac{(1 + \\|y_i - y_j\\|^2)^{-1}}{\\sum_{k \\neq l} (1 + \\|y_k - y_l\\|^2)^{-1}}.\n  $$\n- The heavy tails of the Student-t distribution help to spread out the points and prevent crowding of the points in the lower dimensional space.\n\n---\n\n::: {#762f3d5d .cell execution_count=10}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import t\n\n# Generate data for Gaussian distribution\nmean = 0\nstd_dev = 1\nx = np.linspace(-5, 5, 1000)\ngaussian_y = (1/(std_dev * np.sqrt(2 * np.pi))) * np.exp(-0.5 * ((x - mean) / std_dev)**2)\n\n# Generate data for Student's t-distribution with 10 degrees of freedom\ndf = 1\nt_y = t.pdf(x, df)\n\n# Create the plot\nplt.plot(x, gaussian_y, label='Gaussian Distribution')\nplt.plot(x, t_y, label=\"Student's t-Distribution\", linestyle='dashed')\n\n# Add labels and title\nplt.xlabel('X-axis')\nplt.ylabel('Probability Density')\nplt.title('Gaussian Distribution and Student\\'s t-Distribution')\nplt.legend()\n\n# Show the plot\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](11-Dimensionality-Reduction-SVD-II_files/figure-revealjs/cell-10-output-1.png){width=821 height=449}\n:::\n:::\n\n\n## Step 3: Minimize Kullback-Leibler Divergence\n\n- Minimize the Kullback-Leibler (KL) divergence between the high-dimensional and low-dimensional distributions:\n  $$\n  KL(P \\| Q) = \\sum_{i \\neq j} p_{ij} \\log \\frac{p_{ij}}{q_{ij}}.\n  $$\n- THe KL divergence measures how different the distribution $P$ is from the distribution $Q$. In other words, how different are each of the higher dimensional $P_i$ point distributions from the lower dimensional $Q_i$ distributions.\n- By minimizing this function, we ensure that the lower dimensional point clusters are similar to the higher dimensional clusters.\n- To minimize the KL divergence we use gradient descent to iteratively adjust the positions of points in the low-dimensional space.\n\n\n## Pros of t-SNE\n\n- **Excellent for visualizing complex datasets**: Reveals clusters and patterns that are not visible in high-dimensional space.\n- **Captures non-linear relationships**: Preserves local structure and relationships between points.\n- **Preserves local structure effectively**: Ensures that similar points in high-dimensional space remain close in the low-dimensional representation.\n\n## Cons of t-SNE\n\n- **Computationally intensive**: Requires significant computational resources, especially for large datasets.\n- **Results can vary depending on hyperparameters**: Parameters like perplexity and learning rate can significantly affect the outcome.\n- **Not suitable for all types of data analysis**: Primarily used for visualization, not for tasks like feature extraction or predictive modeling.\n\n## Case Study: Digits\n\nLet's consider how t-SNE performs clustering the MNIST digits datset.\n\n::: {#6f0ba83e .cell execution_count=11}\n``` {.python .cell-code}\nfrom sklearn.manifold import TSNE\nfrom sklearn import datasets\n\ndigits = datasets.load_digits()\nX = digits.data\ny = digits.target\n\ntsne = TSNE(n_components=2, random_state=42)\nX_tsne = tsne.fit_transform(X)\n\nplt.figure(figsize=(7, 7))\nscatter = plt.scatter(X_tsne[:, 0], X_tsne[:, 1], c=y, cmap='tab20', edgecolor='k', s=50)\nplt.title('Digits in t-SNE Space')\nplt.xlabel('tSNE Component 1')\nplt.ylabel('tSNE Component 2')\n\n# Create a legend with discrete labels\nlegend_labels = np.unique(y)\nhandles = [plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=plt.cm.tab20(i / 9), markersize=10) for i in legend_labels]\nplt.legend(handles, legend_labels, title=\"Digit Label\", loc=\"best\")\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](11-Dimensionality-Reduction-SVD-II_files/figure-revealjs/cell-11-output-1.png){width=596 height=597 fig-align='center'}\n:::\n:::\n\n\n## t-SNE vs PCA: Dimensionality Reduction\n\n- **PCA**: Linear method, reduces dimensions by maximizing variance along principal components.\n- **t-SNE**: Non-linear method, focuses on preserving local structure and relationships between points.\n\n\n## t-SNE vs PCA: Visualization\n\n- **PCA**: Good for understanding global structure and variance in the data.\n- **t-SNE**: Superior for visualizing clusters, local relationships, and non-linear structures.\n\n\n## t-SNE vs PCA: Computational Complexity\n\n- **PCA**: Faster and less computationally intensive, suitable for large datasets.\n- **t-SNE**: Slower, requires more computational resources, but provides more detailed visualizations.\n\n# Recap\n\nToday we discussed two dimensionality reduction techniques: PCA and t-SNE.\n\nWe considered both on the MNIST digits dataset.\n\nIn summary\n\n- PCA is a faster, linear dimensionality reduction technique.\n- PCA captures the maximum amount of variance in each principal direction.\n- No parameter adjustments are needed for the SVD.\n- t-SNE is a powerful tool for reducing and visualizing high-dimensional data.\n- Choose t-SNE for detailed visualizations of local structures and clusters.\n- t-SNE is sensitive to changes in it's parameters.\n- Both methods have their own strengths and are chosen based on the specific needs of the analysis.\n\n\n---\n\n",
    "supporting": [
      "11-Dimensionality-Reduction-SVD-II_files"
    ],
    "filters": [],
    "includes": {}
  }
}